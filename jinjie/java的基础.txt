

一、Java 简介  http://www.runoob.com/java/java-intro.html
 

    1、Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。由James Gosling和同事们共同研发，并在1995年正式推出。

    2、Java分为三个体系：

        JavaSE（J2SE）（Java2 Platform Standard Edition，java平台标准版）

        JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版)

        JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)。


    2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名以取消其中的数字"2"：J2EE更名为Java EE, J2SE更名为Java SE，J2ME更名为Java ME。


    3、主要特性：

             Java语言是简单的：

             Java语言是面向对象的：

             Java语言是分布式的：

                     Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（java net），
 
                     它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等。

                     Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。

             Java语言是健壮的：

             Java语言是安全的：
 
             Java语言是体系结构中立的：

                     Java程序（后缀为java的文件）在Java平台上被编译为体系结构中立的字节码格式（后缀为class的文件），

                     然后可以在实现这个Java平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。

             Java语言是可移植的：

             Java语言是解释型的：

             Java是高性能的：

             Java语言是多线程的：

                  在Java语言中，线程是一种特殊的对象，它必须由Thread类或其子（孙）类来创建。

                  通常有两种方法来创建线程：

                        其一，使用型构为Thread(Runnable)的构造子将一个实现了Runnable接口的对象包装成一个线程，

                        其二，从Thread类派生出子类并重写run方法，使用该子类创建的对象即为线程。

                  值得注意的是Thread类已经实现了Runnable接口，因此，任何一个线程均有它的run方法，而run方法中包含了线程所要运行的代码。

                  线程的活动由一组方法来控制。Java语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为synchronized）。


             Java语言是动态的：  

                  Java语言的设计目标之一是适应于动态变化的环境。

                  Java程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。

                  另外，Java中的类有一个运行时刻的表示，能进行运行时刻的类型检查。


     4、发展历史

             。。。

     5、Java开发工具

          Java语言尽量保证系统内存在1G以上，其他工具如下所示：

               Linux 系统、Mac OS 系统、Windows 95/98/2000/XP，WIN 7/8系统。

               Java JDK 7、8……

               Notepad 编辑器或者其他编辑器。

               IDE：Eclipse

---------------------------------------------------------------------------------------------------------------------------------------------

   二、Java 开发环境配置


          window系统安装java
 
           1、 下载JDK

                 首先我们需要下载java开发工具包JDK，

                 下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html，点击如下下载按钮             
 

           2、下载后JDK的安装根据提示进行，还有安装JDK的时候也会安装JRE，一并安装就可以了。

                 安装JDK，安装过程中可以自定义安装目录等信息，例如我们选择安装目录为 C:\Program Files (x86)\Java\jdk1.8.0_91。                


           3、配置环境变量

               1.安装完成后，右击"我的电脑"，点击"属性"，选择"高级系统设置"；
     
               2.选择"高级"选项卡，点击"环境变量"；

               3.在"系统变量"中设置3项属性，JAVA_HOME,PATH,CLASSPATH(大小写无所谓),若已存在则点击"编辑"，不存在则点击"新建"。

                        变量设置参数如下：

                            变量名：JAVA_HOME

                                变量值：C:\Program Files (x86)\Java\jdk1.8.0_91        // 要根据自己的实际路径配置

                            变量名：CLASSPATH

                                变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;         //记得前面有个"."

                            变量名：Path

                                变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;


           4、这是 Java 的环境配置，配置完成后，你可以启动 Eclipse 来编写代码，它会自动完成java环境的配置。

                注意：如果使用1.5以上版本的JDK，不用设置CLASSPATH环境变量，也可以正常编译和运行Java程序。


           5、测试JDK是否安装成功

                1、"开始"->"运行"，键入"cmd"；

                2、键入命令: java -version、java、javac 几个命令，出现以下信息，说明环境变量配置成功；


---------------------------------------------------------------------------------------------------------------------------------------------


   三、Java 基础语法
 

       1、一个Java程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。下面简要介绍下类、对象、方法和实例变量的概念。


         对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。

           类：类是一个模板，它描述一类对象的行为和状态。

         方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。

     实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。



        2、第一个Java程序

             下面看一个简单的Java程序，它将打印字符串 Hello World

             实例
             public class HelloWorld {
                 /* 第一个Java程序
                  * 它将打印字符串 Hello World
                  */
                 public static void main(String []args) {
                     System.out.println("Hello World"); // 打印 Hello World
                 }
             } 


            下面将逐步介绍如何保存、编译以及运行这个程序：

                              打开Notepad，把上面的代码添加进去；

                              把文件名保存为：HelloWorld.java；

                              打开cmd命令窗口，进入目标文件所在的位置，假设是C:\

                              在命令行窗口键入 javac HelloWorld.java  按下enter键编译代码。如果代码没有错误，cmd命令提示符会进入下一行。（假设环境变量都设置好了）。

                              再键入java HelloWorld 按下Enter键就可以运行程序了


        3、基本语法

              编写Java程序时，应注意以下几点：

                         大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。

                         类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，

                                      例如 MyFirstJavaClass 。

                         方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。

                         源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。

                         主方法入口：所有的Java 程序由public static void main(String []args)方法开始执行。


       4、Java标识符

             Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。

             关于Java标识符，有以下几点需要注意：

                      所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始

                      首字符之后可以是字母（A-Z或者a-z）,美元符（$）、下划线（_）或数字的任何字符组合

                      关键字不能用作标识符

                      标识符是大小写敏感的

                      合法标识符举例：age、$salary、_value、__1_value

                      非法标识符举例：123abc、-salary


       5、Java修饰符

             像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：

                     访问控制修饰符 : default, public , protected, private

                     非访问控制修饰符 : final, abstract, strictfp

                     在后面的章节中我们会深入讨论Java修饰符。


       6、Java变量

              Java中主要有如下几种类型的变量：

                                    局部变量

                                    类变量（静态变量）

                                    成员变量（非静态变量）


       7、Java数组

             数组是储存在堆上的对象，可以保存多个同类型变量。在后面的章节中，我们将会学到如何声明、构造以及初始化一个数组。


       8、Java枚举

            Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的bug。

            例如，我们为果汁店设计一个程序，它将限制果汁为小杯、中杯、大杯。这就意味着它不允许顾客点除了这三种尺寸外的果汁。

                 实例

                 class FreshJuice {
                    enum FreshJuiceSize{ SMALL, MEDIUM , LARGE }
                    FreshJuiceSize size;
                 }
 
                 public class FreshJuiceTest {
                    public static void main(String []args){
                       FreshJuice juice = new FreshJuice();
                       juice.size = FreshJuice.FreshJuiceSize.MEDIUM  ;
                    }
                 }
 
                注意：枚举可以单独声明或者声明在类里面。方法、变量、构造函数也可以在枚举中定义。


       9、Java关键字

             。。。

       10、Java注释

            类似于C/C++，Java也支持单行以及多行注释。注释中的字符将被Java编译器忽略。

       11、Java 空行

             空白行，或者有注释的行，Java编译器都会忽略掉。

       12、继承

            在Java中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。

            利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（subclass）。


       13、接口

            在Java中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。

            接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。



---------------------------------------------------------------------------------------------------------------------------------------------

  
   四、Java 对象和类

          Java作为一种面向对象语言。支持以下基本概念：

               多态     继承     封装

               抽象      类      对象

               实例     方法     重载
 

       1、Java中的对象

       2、Java中的类
               
             类可以看成是创建Java对象的模板。

             一个类可以包含以下类型变量：

                 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。

                 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。

                 类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。


             一个类可以拥有多个方法，在上面的例子中：barking()、hungry()和sleeping()都是Dog类的方法。


      3、构造方法

            每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。

            在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。

                  下面是一个构造方法示例：
                  public class Puppy{
                      public Puppy(){
                      }
 
                      public Puppy(String name){
                          // 这个构造器仅有一个参数：name
                      }
                  }

      4、创建对象

           对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步：


                       声明：声明一个对象，包括对象名称和对象类型。

                       实例化：使用关键字new来创建一个对象。

                       初始化：使用new创建对象时，会调用构造方法初始化对象。

                       例子：

                             public class Puppy{
                                public Puppy(String name){
                                   //这个构造器仅有一个参数：name
                                   System.out.println("小狗的名字是 : " + name ); 
                                }
                                public static void main(String []args){
                                   // 下面的语句将创建一个Puppy对象
                                   Puppy myPuppy = new Puppy( "tommy" );
                                }
                             }

      5、访问实例变量和方法

                   通过已创建的对象来访问成员变量和成员方法，如下所示：

                   /* 实例化对象 */

                          ObjectReference = new Constructor();

                   /* 访问其中的变量 */

                          ObjectReference.variableName;

                   /* 访问类中的方法 */

                          ObjectReference.MethodName();


      6、源文件声明规则

          在本节的最后部分，我们将学习源文件的声明规则。

          当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。

                    一个源文件中只能有一个public类

                    一个源文件可以有多个非public类

                    源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。

                    如果一个类定义在某个包中，那么package语句应该在源文件的首行。

                    如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。

                    import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。
 
                 
          类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。这些将在访问控制章节介绍。

          除了上面提到的几种类型，Java还有一些特殊的类，如：内部类、匿名类。


      7、Java包

           包主要用来对类和接口进行分类。当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。

      8、Import语句

           在Java中，如果给出一个完整的限定名，包括包名、类名，那么Java编译器就可以很容易地定位到源代码或者类。

           Import语句就是用来提供一个合理的路径，使得编译器可以找到某个类。


         注意：
               1. ackage 的作用就是 c++ 的 namespace 的作用，防止名字相同的类产生冲突。Java 编译器在编译时，直接根据 package 指定的信息直接将生成的 class 文件生成到对应目录下。

               2.import 是为了简化使用 package 之后的实例化的代码。

                     假设 ./aaa/bbb/ccc/ 下的 A 类，

                        假如没有 import，实例化A类为：new aaa.bbb.ccc.A()，

                        使用 import aaa.bbb.ccc.A 后，就可以直接使用 new A() 了，也就是编译器匹配并扩展了 aaa.bbb.ccc. 这串字符串。


              3.为什么JAVA文件中只能含有一个Public类?

                  java 程序是从一个 public 类的 main 函数开始执行的，(其实是main线程)，就像 C 程序 是从 main() 函数开始执行一样。 只能有一个

                  public 类是为了给类装载器提供方便。 一个 public 类只能定义在以它的类名为文件名的文件中。
           

---------------------------------------------------------------------------------------------------------------------------------------------


  五、Java 基本数据类型


        变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。

        内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。

        因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。

        Java 的两大数据类型:

                         内置数据类型

                         引用数据类型


        


        1、内置数据类型

              Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。


              （1）byte：

                     byte 数据类型是8位、有符号的，以二进制补码表示的整数；
       
                     byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；


              （2）short：

                     short 数据类型是 16 位、有符号的以二进制补码表示的整数

                     Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；

                     例子：short s = 1000，short r = -20000。

              （3）int：

                     int 数据类型是32位、有符号的以二进制补码表示的整数；

                     一般地整型变量默认为 int 类型；



              （4）long：

                    long 数据类型是 64 位、有符号的以二进制补码表示的整数；

                    这种类型主要使用在需要比较大整数的系统上；

                    默认值是 0L；

                    例子： long a = 100000L，Long b = -200000L。

                    "L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。

              
              （5）float：

                    float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；

                    float 在储存大型浮点数组的时候可节省内存空间；

                    默认值是 0.0f；

                    浮点数不能用来表示精确的值，如货币；

                    例子：float f1 = 234.5f。
 

             （6）double：

                    double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；

                    浮点数的默认类型为double类型；

                    double类型同样不能表示精确的值，如货币；

                    默认值是 0.0d；

                    例子：double d1 = 123.4。


             （7）boolean：

                    boolean数据类型表示一位的信息；

                    只有两个取值：true 和 false；

                    这种类型只作为一种标志来记录 true/false 情况；

                    默认值是 false；

                    例子：boolean one = true。


             （8）char：

                    char类型是一个单一的 16 位 Unicode 字符；

                    最小值是 \u0000（即为0）；

                    最大值是 \uffff（即为65,535）；

                    char 数据类型可以储存任何字符；

                    例子：char letter = 'A';。



        2、引用类型

              在Java中，引用类型的变量非常类似于C/C++的指针。

              引用类型指向一个对象，指向对象的变量是引用变量。

              这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。


              对象、数组都是引用数据类型。

              所有引用类型的默认值都是null。

              一个引用变量可以用来引用与任何与之兼容的类型。

              例子：Site site = new Site("Runoob")。


       3、Java常量

        （1） 常量在程序运行时，不会被修改的量。

              在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：

                  final double PI = 3.1415927;

              虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。


        （2）  字面量可以赋给任何内置类型的变量。例如：

                                   byte a = 68;
                                   char a = 'A'

        （3）byte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示。

               当使用常量的时候，前缀0表示8进制，而前缀0x代表16进制。例如：

                                    int decimal = 100;
                                    int octal = 0144;
                                    int hexa =  0x64;

        （4）和其他语言一样，Java的字符串常量也是包含在两个引号之间的字符序列。下面是字符串型字面量的例子：

                                    "Hello World"
                                    "two\nlines"
                                    "\"This is in quotes\""

        （5）字符串常量和字符常量都可以包含任何Unicode字符。例如：

                                    char a = '\u0001';
                                    String a = "\u0001";




     4、自动类型转换

           整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。

           转换从低级到高级。
 
               低  ------------------------------------>  高

                byte,short,char―> int ―> long―> float ―> double 

             据类型转换必须满足如下规则：

                        1. 不能对boolean类型进行类型转换。

                        2. 不能把对象类型转换成不相关类的对象。

                        3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。

                        4. 转换过程中可能导致溢出或损失精度，例如： 

                                  例如：

                                  int i =128;   
                                  byte b = (byte)i;

                                  因为byte类型时8位，最大值为127，所以当强制转换为int类型值128时候就会导致溢出。


                        5. 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：

                                  (int)23.7 == 23;        
                                  (int)-45.89f == -45


       （1）自动类型转换

                必须满足转换前的数据类型的位数要低于转换后的数据类型，

                例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。

               例:

                 char c1='a';//定义一个char类型

                 int i1 = c1;//char自动类型转换为int

                //char自动类型转换为int后的值等于97
                //解析：c1的值为字符'a',查ascii码表可知对应的int类型值为97


  
        (2)强制类型转换

                1. 条件是转换的数据类型必须是兼容的。

                2. 格式：(type)value type是要强制类型转换后的数据类型 实例：

                例：
                      int i1 = 123;
                      byte b = (byte)i1;//强制类型转换为byte
                      System.out.println("int强制类型转换为byte后的值等于"+b);

                      //int强制类型转换为byte后的值等于123

        （3）隐含强制类型转换

               1. 整数的默认类型是 int。
 
               2. 浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或者 f。


        注意：
              Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析：

              引用类型是一个对象类型，它的值是指向内存空间的引用，就是地址，所指向的内存中保存着变量所表示的一个值或一组值。

          例：

         ①   int a;
            a = 250; // 声明变量a的同时，系统给a分配了空间。

            引用类型就不是了，只给变量分配了引用空间，数据空间没有分配，因为不知道数据是什么。


         ② 引用类型变量在声明后必须通过实例化开辟数据空间，才能对变量所指向的对象进行访问。
              
                  MyDate today;          //将变量分配一个保存引用的空间

                  today = new MyDate();     // 这句话是2步，首先执行new MyDate（），给today变量开辟数据空间，然后再执行赋值操作

         ③引用变量赋值：

                MyDate a，b;       // 在内存开辟两个引用空间

                a = new MyDate();       // 开辟MyDate对象的数据空间，并把该空间的首地址赋给a

                b = a;     


           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      
         注意：
                      short a = 1;
                      short b = 2;

                 那么 a+b 是什么类型？

                 答：在java的世界里，如果比int类型小的类型做运算，java在编译的时候就会将它们统一强转成int类型。

                     当是比int类型大的类型做运算，就会自动转换成它们中最大类型那个。


           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

         注意：

               char a = 'S'; char 后面赋值要用单引号，因为是字符型数据类型

               String a = "I AM FINE"; String 后面赋值要用双引号，因为是字符串数据类型



---------------------------------------------------------------------------------------------------------------------------------------------


  六、Java 变量类型


        在Java语言中，所有的变量在使用前必须声明。声明变量的基本格式如下：

                     type identifier [ = value][, identifier [= value] ...] ;

        格式说明：type为Java数据类型。identifier是变量名。可以使用逗号隔开来声明多个同类型变量。


        以下列出了一些变量的声明实例。注意有些包含了初始化过程。

                       int a, b, c;         // 声明三个int型整数：a、 b、c

                       int d = 3, e = 4, f = 5; // 声明三个整数并赋予初值

                       byte z = 22;         // 声明并初始化 z

                       String s = "runoob";  // 声明并初始化字符串 s

                       double pi = 3.14159; // 声明了双精度浮点型变量 pi

                       char x = 'x';        // 声明变量 x 的值是字符 'x'。


          Java语言支持的变量类型有：

                        类变量：独立于方法之外的变量，用 static 修饰。

                        实例变量：独立于方法之外的变量，不过没有 static 修饰。

                        局部变量：类的方法中的变量。


                        实例
                        public class Variable{
                            static int allClicks=0;    // 类变量
 
                            String str="hello world";  // 实例变量
 
                            public void method(){
                         
                                int i =0;  // 局部变量
 
                            }
                        }


        1、 Java 局部变量：

                   局部变量声明在方法、构造方法或者语句块中；

              ---> 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；

              ---> 访问修饰符不能用于局部变量；

                   局部变量只在声明它的方法、构造方法或者语句块中可见；

                   局部变量是在栈上分配的。

              ---> 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。


        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        2、实例变量（成员变量）

                   实例变量声明在一个类中，但在方法、构造方法和语句块之外；

                   当一个对象被实例化之后，每个实例变量的值就跟着确定；

              ---> 实例变量在对象创建的时候创建，在对象被销毁的时候销毁；

                   实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；

                   实例变量可以声明在使用前或者使用后；

              ---> 访问修饰符可以修饰实例变量；

              ---> 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；

              ---> 实例变量具有默认值。

                            数值型变量的默认值是0，

                            布尔型变量的默认值是false，

                            引用类型变量的默认值是null。

                       变量的值可以在声明时指定，也可以在构造方法中指定；

                   实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。


         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

       3、类变量（静态变量）

              ---> 类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。

              ---> 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。

              ---> 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。

              ---> 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。

                   静态变量在程序开始时创建，在程序结束时销毁。

              ---> 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。

                   默认值和实例变量相似。

                            数值型变量默认值是0，
        
                            布尔型默认值是false，

                            引用类型默认值是null。

                     变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。

              ---> 静态变量可以通过：ClassName.VariableName的方式访问。

              ---> 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。

                         如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。




         注意：

             1、Java 中静态变量和实例变量区别：

                    静态变量属于类，该类不生产对象，通过类名就可以调用静态变量。

                    实例变量属于该类的对象，必须产生该类对象，才能调用实例变量。


             2、在程序运行时的区别：

                   实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。

                   静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。
 
             总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。


             3、java 实例变量在整个类内部是可访问的，而不管实例变量声明在类的哪个位置。


             4、无final修饰，声明时赋值，构造器中赋值，静态语句块或静态方法赋值

                有final修饰，声明时赋值，声明与赋值分开可在静态语句块中赋值




---------------------------------------------------------------------------------------------------------------------------------------------

    七、Java 修饰符
 
                 Java语言提供了很多修饰符，主要分为以下两类：

                                     访问修饰符

                                     非访问修饰符

               修饰符用来定义类、方法或者变量，通常放在语句的最前端。
         

      1、访问控制修饰符

           Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Javav支持 4 种不同的访问权限。

              default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。

              private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）

              public : 对所有类可见。使用对象：类、接口、变量、方法

              protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。
  

           可见范围由大到小：  public --->  protected  --->  default  ---->  private


        （1）默认访问修饰符-不使用任何关键字

                使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。
 
                接口里的变量都隐式声明为 public static final,而接口里的方法默认情况下访问权限为 public。


        （2）私有访问修饰符-private

                私有访问修饰符是最严格的访问级别，所以被声明为 private 的方法、变量和构造方法只能被所属类访问

                注意：类和接口不能声明为 private。

    
        （3）公有访问修饰符-public

                被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。

                如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。

                Java 程序的 main() 方法必须设置成公有的，否则，Java 解释器将不能运行该类。


        （4）受保护的访问修饰符-protected

                被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问，也能够被不同包中的子类访问。

                protected 访问修饰符不能修饰类和接口，方法和成员变量能够声明为 protected，但是接口的成员变量和成员方法不能声明为 protected。


       （5）访问控制和继承

               请注意以下方法继承的规则：

                   父类中声明为 public 的方法在子类中也必须为 public。

                   父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。

                   父类中声明为 private 的方法，不能够被继承。  

           //注意：父类中声明为 private 的方法，不能够被继承。但private的变量是可以继承的


      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      2、非访问修饰符

           为了实现一些其他的功能，Java 也提供了许多非访问修饰符。

              static 修饰符，用来修饰类方法和类变量。

              final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。

              abstract 修饰符，用来创建抽象类和抽象方法。

              synchronized 和 volatile 修饰符，主要用于线程的编程。


        （1）static 修饰符

        （2）final 修饰符

              final 变量：    
 
                      final 变量能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。

                      但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。

                      final 修饰符通常和 static 修饰符一起使用来创建类常量。


              final 方法：

                   类中的 final 方法可以被子类继承，但是不能被子类修改。

                   声明 final 方法的主要目的是防止该方法的内容被修改。


              final 类：

                  final 类不能被继承，没有类能够继承 final 类的任何特性。


        （3）abstract 修饰符

              抽象类：

                   抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。

                   一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。

                   抽象类可以包含抽象方法和非抽象方法。


              抽象方法：

                   抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。

                   抽象方法不能被声明成 final 和 static。

                   任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。

                   如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。


        （4）synchronized 修饰符

               synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。

               实例
               public synchronized void showDetails(){
                     .......
               }


        （5）transient 修饰符   --》 阻止变量的持久化

               序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。

               该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。

                  transient Integer age; //年龄

               transient阻止实例中那些用此关键字声明的变量持久化；当对象被反序列化时（从源文件读取字节序列进行重构），这样的实例变量值不会被持久化和恢复。

                           


        （6）volatile 修饰符

               volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。

               一个 volatile 对象引用可能是 null。

                   public class MyRunnable implements Runnable
                   {
                       private volatile boolean active;
                       public void run()
                       {
                           active = true;
                           while (active) // 第一行
                           {
                               // 代码
                           }
                       }
                       public void stop()
                       {
                           active = false; // 第二行
                       }
                   }

          通常情况下，在一个线程调用 run() 方法（在 Runnable 开启的线程），在另一个线程调用 stop() 方法。

          如果 第一行 中缓冲区的 active 值被使用，那么在 第二行 的 active 值为 false 时循环不会停止。

          但是以上代码中我们使用了 volatile 修饰 active，所以该循环会停止。


---------------------------------------------------------------------------------------------------------------------------------------------


   八、Java 运算符

             算术运算符：+ - * / %....


             关系运算符： ==  !=  >  < ...


             位运算符: ＆ | ^ 


             逻辑运算符: &&    ||   ！

                 短路逻辑运算符 : 当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。
 
                 实例：
                      int a = 5;//定义一个变量；
                      boolean b = (a<4)&&(a++<10)

                 运行结果为：
                            使用短路逻辑运算符的结果为false
                            a的结果为5

                 解析： 该程序使用到了短路逻辑运算符(&&)，首先判断 a<4 的结果为 false，则 b 的结果必定是 false，所以不再执行第二个操作 a++<10 的判断，所以 a 的值为 5。
 

             赋值运算符： =  +=  -=   （％）=  ＆=


             其他运算符：

                   （1）条件运算符（?:）

                            条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。

                        例子： 
                               // 如果 a 等于 1 成立，则设置 b 为 20，否则为 30
                                   b = (a == 1) ? 20 : 30;


                   （2）instanceof 运算符
      
                          该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。

                          instanceof运算符使用格式如下：

                               ( Object reference variable ) instanceof  (class/interface type)                          

                               如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。

                          下面是一个例子：

                               String name = "James";
                               boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真
                               如果被比较的对象兼容于右侧类型,该运算符仍然返回true。


             Java运算符优先级

                  当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。

                  在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。

                  例如，（1+3）＋（3+2）*2，这个表达式如果按加号最优先计算，答案就是 18，如果按照乘号最优先，答案则是 14。

           
             注意：

                   在判断一个实例引用的类型时，使用的是实际类型，而不是声明的类型。在下面的代码中：

                            public class Car extends Vehicle {}

                                       //Car 是 Vehicle类型, Vehicle 不是 Car 类型
 
                            Vehicle v2 = new Car();    // v2 是 Car 类型

                                      //v2 是 Car 类型，而不是 Vehicle 类型。



                                    Car c1 = new Car();

                                    Vehicle v2 = new Car();    // v2 是 Car 类型
                                    Vehicle v3 = new Vehicle();

                                    //Car 是 Vehicle类型, Vehicle 不是 Car 类型
                                    boolean result1 =  c1 instanceof Vehicle;    // true
                                    boolean result2 =  v2 instanceof Car;        // true
                                    boolean result3 =  v2 instanceof Vehicle;    // true
                                    boolean result4 =  v3 instanceof Car;          // false



---------------------------------------------------------------------------------------------------------------------------------------------

   九、Java 循环结构 - for, while 及 do...while


      1、顺序结构的程序语句只能被执行一次。如果您想要同样的操作执行多次,，就需要使用循环结构。

         Java中有三种主要的循环结构：

                                     while 循环

                                     do…while 循环

                                     for 循环

                          在Java5中引入了一种主要用于数组的增强型for循环。


      2、 Java 增强 for 循环：

           Java5 引入了一种主要用于数组的增强型 for 循环。

              Java 增强 for 循环语法格式如下:

                   for(声明语句 : 表达式)
                   {
                      //代码句子
                   }
           
            声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。

            表达式：表达式是要访问的数组名，或者是返回值为数组的方法。


             public class Test {
                public static void main(String args[]){
                   int [] numbers = {10, 20, 30, 40, 50};
 
                   for(int x : numbers ){
                      System.out.print( x );
                      System.out.print(",");
                   }
                   System.out.print("\n");
                   String [] names ={"James", "Larry", "Tom", "Lacy"};
                   for( String name : names ) {
                      System.out.print( name );
                      System.out.print(",");
                   }
                }
             }

        3、break 关键字  和  continue 关键字

        4、for循环嵌套：以打印九九乘法表为例


---------------------------------------------------------------------------------------------------------------------------------------------


   十、Java 分支结构 - if...else/switch

         顺序结构只能顺序执行，不能进行判断和选择，因此需要分支结构。

          Java 有两种分支结构：

                     if 语句

                     switch 语句

          if 语句

          if...else语句

          if...else if...else 语句

          嵌套的 if…else 语句


          switch 语句

            switch 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。

            语法

            switch 语法格式如下：
            switch(expression){
                case value :
                   //语句
                   break; //可选
                case value :
                   //语句
                   break; //可选
                //你可以有任意数量的case语句
                default : //可选
                   //语句
            }

          实例：

           public class Test {
           public static void main(String args[]){
                 //char grade = args[0].charAt(0);
                 char grade = 'C';
 
                 switch(grade)
                 {
                    case 'A' :
                       System.out.println("优秀"); 
                       break;
                    case 'B' :
                    case 'C' :
                       System.out.println("良好");
                       break;
                    case 'D' :
                       System.out.println("及格");
                    case 'F' :
                       System.out.println("你需要再努力努力");
                       break;
                    default :
                       System.out.println("未知等级");
                 }
                 System.out.println("你的等级是 " + grade);
              }
           }



---------------------------------------------------------------------------------------------------------------------------------------------


  十一、Java Number & Math 类

          一般地，当需要使用数字的时候，我们通常使用内置数据类型，如：byte、int、long、double 等。

         在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，Java 语言为每一个内置数据类型提供了对应的包装类。

         所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。


       1、Java Math 类

           Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。

           Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。

           Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。

           Test.java 文件代码：
           public class Test {  
               public static void main (String []args)  
               {  
                   System.out.println("90 度的正弦值：" + Math.sin(Math.PI/2));  
                   System.out.println("0度的余弦值：" + Math.cos(0));  
                   System.out.println("60度的正切值：" + Math.tan(Math.PI/3));  
                   System.out.println("1的反正切值： " + Math.atan(1));  
                   System.out.println("π/2的角度值：" + Math.toDegrees(Math.PI/2));  
                   System.out.println(Math.PI);  
               }  
           }

    

       2、Number & Math 类方法

           下面的表中列出的是 Number & Math 类常用的一些方法：

            1.xxxValue()

                将 Number 对象转换为xxx数据类型的值并返回。

            2.compareTo()

                将number对象与参数比较。

            3.equals()

                判断number对象是否与参数相等。

            4.valueOf()

                返回一个 Number 对象指定的内置数据类型

            5.toString()

               以字符串形式返回值。

            6.parseInt()

               将字符串解析为int类型。

            7.abs()

               返回参数的绝对值

            8.ceil()

               对整形变量向左取整，返回类型为double型

            9.floor()

               对整型变量向右取整。返回类型为double类型。

            10.rint()

               返回与参数最接近的整数。返回类型为double。

            11.round()

               返回一个最接近的int、long型值。


            12.min()

               返回一个最接近的int、long型值。            

            13.max()

               返回两个参数中的最大值。

            14.exp()

               返回自然数底数e的参数次方。

            15.sqrt()

               求参数的算术平方根。

            16.random()

               返回一个随机数。

            ....有27个


       注意：
              == 与 equals的区别

                 == 它比较的是对象的地址
        
                 equlas 比较的是对象的内容

                //整型是基本数据类型
		 Integer a = 200;
		 Integer b = 200;

		 System.out.println("== 比较：" + (a==b));   //false -->整型是基本数据类型,所以对象的地址不同
		 System.out.println("equals 比较:" + a.equals(b)); //true


                //String 是引用类型
		 String c = "haha";
		 String d = "haha";

		 System.out.println("== 比较：" + (c==d));   //true  -->-->String 是引用类型,"haha"是一个对象，所以对象的地址相同
		 System.out.println("equals 比较:" + c.equals(d)); //true


---------------------------------------------------------------------------------------------------------------------------------------------

  十二、Java Character 类  ---》 针对的都对 字符串长度为1 的, 只能存 单字符， 所以用的是单引号，而不是双引号

     1、 Character 类用于对单个字符进行操作。

         Character 类在对象中包装一个基本类型 char 的值

         实例
         char ch = 'a';
 
         // Unicode 字符表示形式
         char uniChar = '\u039A'; 
 
         // 字符数组
         char[] charArray ={ 'a', 'b', 'c', 'd', 'e' };

         然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情况。为了解决这个问题，Java语言为内置数据类型char提供了包装类Character类。

         Character类提供了一系列方法来操纵字符。你可以使用Character的构造方法创建一个Character类对象，例如：

                 Character ch = new Character('a');

         在某些情况下，Java编译器会自动创建一个Character对象。

          例如，将一个char类型的参数传递给需要一个Character类型参数的方法时，那么编译器会自动地将char类型参数转换为Character对象。
 
          这种特征称为装箱，反过来称为拆箱。

            实例
            // 原始字符 'a' 装箱到 Character 对象 ch 中

            Character ch = 'a';
 
            // 原始字符 'x' 用 test 方法装箱
            // 返回拆箱的值到 'c'

            char c = test('x');


      2、转义序列  

           \n	在文中该处换行          //newline 向下移动一行，并不移动左右。
           
           \r	在文中该处插入回车      //return 到当前行的最左边。

           \f	在文中该处插入换页符

           \"	在文中该处插入双引号

           \\	在文中该处插入反斜杠

            .....

            注意：
                     Linux中\n表示：回车+换行；

                     Windows中\r\n表示：回车+换行。

                     Mac中\r表示：回车+换行。



       3、Character 方法

           isLetter()         是否是一个字母

           isDigit()          是否是一个数字字符

	   isWhitespace()     是否是一个空格

	   isUpperCase()      是否是大写字母

	   isLowerCase()      是否是小写字母

	   toUpperCase()      指定字母的大写形式

	   toLowerCase()      指定字母的小写形式

           toString()         返回字符的字符串形式，字符串的长度仅为1



---------------------------------------------------------------------------------------------------------------------------------------------


  十三、Java String 类


         字符串广泛应用 在Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。

        1、创建字符串

            创建字符串最简单的方式如下:

                  String greeting = "菜鸟教程";   //"菜鸟教程" 是一个对象


            String 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，比如提供一个字符数组参数:

                     char[] helloArray = { 'r', 'u', 'n', 'o', 'o', 'b'};
                     String helloString = new String(helloArray);  


            注意:String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了
                 
                 如果需要对字符串做很多修改，那么应该选择使用 StringBuffer & StringBuilder 类。


       2、字符串长度length()

             String 类的一个访问器方法是 length() 方法，它返回字符串对象包含的字符数。


       3、连接字符串

              String 类提供了连接两个字符串的方法：

                     ①、string1.concat(string2);

                               "我的名字是 ".concat("Runoob");


                     ②常用的是使用'+'操作符来连接字符串，如：

                               "Hello," + " runoob" + "!"


       4、创建格式化字符串

            我们知道输出格式化数字可以使用 printf() 和 format() 方法。

            String 类使用静态方法 format() 返回一个String 对象而不是 PrintStream 对象。

            String 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。


           如下所示：
           System.out.printf("浮点型变量的值为 " +
                             "%f, 整型变量的值为 " +
                             " %d, 字符串变量的值为 " +
                             "is %s", floatVar, intVar, stringVar);
           你也可以这样写
           String fs;
           fs = String.format("浮点型变量的值为 " +
                              "%f, 整型变量的值为 " +
                              " %d, 字符串变量的值为 " +
                              " %s", floatVar, intVar, stringVar);

 
      5、String 方法  http://www.runoob.com/java/java-string.html

            1.char charAt(int index)

                  返回指定索引处的 char 值。

            2.int compareTo(Object o)

                  把这个字符串和另一个对象比较。

            3.String concat(String str)

                 将指定字符串连接到此字符串的结尾。

            4.boolean contentEquals(StringBuffer sb)

                 当且仅当字符串与指定的StringButter有相同顺序的字符时候返回真。

            5.boolean equals(Object anObject)

                 将此字符串与指定的对象比较。

            6.	byte[] getBytes()

                 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。

            7.int indexOf(int ch)

                返回指定字符在此字符串中第一次出现处的索引。

            8.int length()

                返回此字符串的长度。

            9.boolean matches(String regex)

                告知此字符串是否匹配给定的正则表达式。

            10.String[] split(String regex)

                根据给定正则表达式的匹配拆分此字符串。
  
            11.String substring(int beginIndex)

                返回一个新的字符串，它是此字符串的一个子字符串。

            12.char[] toCharArray()

                将此字符串转换为一个新的字符数组。

            13.String toLowerCase()

               使用默认语言环境的规则将此 String 中的所有字符都转换为小写。

            14.String toString()

               返回此对象本身（它已经是一个字符串！）。

            15.String trim()

               返回字符串的副本，忽略前导空白和尾部空白。
       
             .......


        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

         注意：
               String 类是不可改变的解析，例如：

                        String s = "Google";
                        System.out.println("s = " + s);

                        s = "Runoob";
                        System.out.println("s = " + s);
        
                        输出结果为：
                                     Google
                                     Runoob

            从结果上看是改变了，但为什么门说String对象是不可变的呢？

            解析： 原因在于实例中的 s 只是一个 String 对象的引用，并不是对象本身，当执行 s = "Runoob"; 创建了一个新的对象 "Runoob"，而原来的 "Google" 还存在于内存中。


            注意:String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了
                 
                 如果需要对字符串做很多修改，那么应该选择使用 StringBuffer & StringBuilder 类。

---------------------------------------------------------------------------------------------------------------------------------------------


   十四、Java StringBuffer 和 StringBuilder 类

        1、 当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。

           和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。              


        2、StringBuffer 和 StringBuilder 区别
 
             StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。

             由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。

             然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。

             Test.java 文件代码：
             public class Test{
               public static void main(String args[]){
                 StringBuffer sBuffer = new StringBuffer("菜鸟教程官网：");
                 sBuffer.append("www");
                 sBuffer.append(".runoob");
                 sBuffer.append(".com");
                 System.out.println(sBuffer);  
               }
             }

        3、StringBuffer 方法（与StringBuilder 方法一样）

             以下是 StringBuffer 类支持的主要方法：

               1.public StringBuffer append(String s)

                      将指定的字符串追加到此字符序列。


               2.public StringBuffer reverse()

                      将此字符序列用其反转形式取代。


               3.public delete(int start, int end)

                      移除此序列的子字符串中的字符。


               4.public insert(int offset, int i)

                      将 int 参数的字符串表示形式插入此序列中。


               5.replace(int start, int end, String str)

                      使用给定 String 中的字符替换此序列的子字符串中的字符。


              下面的列表里的方法和 String 类的方法类似：

                  1.int capacity()

                          返回当前容量。

                  2.char charAt(int index)

                          返回此序列中指定索引处的 char 值。

                  3.int indexOf(String str)

                          返回第一次出现的指定子字符串在该字符串中的索引。

                  4.int length()

                          返回长度（字符数）。

                  5.String substring(int start)

                          返回一个新的 String，它包含此字符序列当前所包含的字符子序列。

                  6.String toString()

                          返回此序列中数据的字符串表示形式。



      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

       注意:        

          Java 中 StringBuffer 和 String 是有一定的区别的，首先，String 是被 final 修饰的，他的长度是不可变的，就算调用 String 的concat 方法，

          那也是把字符串拼接起来并重新创建一个对象，把拼接后的 String 的值赋给新创建的对象，

          而 StringBuffer 的长度是可变的，调用StringBuffer 的 append 方法，来改变 StringBuffer 的长度，并且，相比较于 StringBuffer，String 一旦发生长度变化，是非常耗费内存的！



          String 长度大小不可变

          StringBuffer 和 StringBuilder 长度可变

          StringBuffer 线程安全 StringBuilder 线程不安全

          StringBuilder 速度快



---------------------------------------------------------------------------------------------------------------------------------------------


  十五、Java 数组

          数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。

          Java 语言中提供的数组是用来存储固定大小的同类型元素。     

          你可以声明一个数组变量，如 numbers[100] 来代替直接声明 100 个独立变量 number0，number1，....，number99。


      1、声明数组变量

            首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：        

                   ①   dataType[] arrayRefVar;  // 首选的方法

                   ②   dataType arrayRefVar[];  // 效果相同，但不是首选方法


               注意: 建议使用 dataType[] arrayRefVar 的声明风格声明数组变量。

                     dataType arrayRefVar[] 风格是来自 C/C++ 语言 ，在Java中采用是为了让 C/C++ 程序员能够快速理解java语言。
                  
                  实例
                  下面是这两种语法的代码示例：
      
                    ①  double[] myList;   // 首选的方法

                    ②  double myList[];   // 效果相同，但不是首选方法


      2、创建数组

           Java语言使用new操作符来创建数组，语法如下：

               arrayRefVar = new dataType[arraySize];


           上面的语法语句做了两件事：

               一、使用 dataType[arraySize] 创建了一个数组。

               二、把新创建的数组的引用赋值给变量 arrayRefVar。


           数组变量的声明，和创建数组可以用一条语句完成，如下所示：

                dataType[] arrayRefVar = new dataType[arraySize];


           另外，你还可以使用如下的方式创建数组：

                dataType[] arrayRefVar = {value0, value1, ..., valuek};

               数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 arrayRefVar.length-1。


     3、处理数组

           数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本循环或者 foreach 循环。

               double[] myList = {1.9, 2.9, 3.4, 3.5};

            基本循环：

                for (int i = 1; i < myList.length; i++) {

                          if (myList[i] > max) max = myList[i];
                 }


           foreach循环：

               for (double element: myList) {

                         System.out.println(element);
                 }


      4、数组作为函数的参数

           数组可以作为参数传递给方法。

           例如，下面的例子就是一个打印 int 数组中元素的方法:

                          public static void printArray(int[] array) {
                            for (int i = 0; i < array.length; i++) {
                              System.out.print(array[i] + " ");
                            }
                          }

     5、数组作为函数的返回值

               public static int[] reverse(int[] list) {

                      int[] result = new int[list.length];
 
                      for (int i = 0, j = result.length - 1; i < list.length; i++, j--) {
                              result[j] = list[i];
                        }
                        return result;
                      }
                      以上实例中 result 数组作为函数的返回值。


     6、多维数组

          多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组，

          例如：

              String str[][] = new String[3][4];


          1.多维数组的动态初始化（以二维数组为例）

               1. 直接为每一维分配空间，格式如下：

                    int a[][] = new int[2][3];
 
                   解析：

                      二维数组 a 可以看成一个两行三列的数组。


               2. 从最高维开始，分别为每一维分配空间，例如：

                            String s[][] = new String[2][];
                            s[0] = new String[2];
                            s[1] = new String[3];
                            s[0][0] = new String("Good");
                            s[0][1] = new String("Luck");
                            s[1][0] = new String("to");
                            s[1][1] = new String("you");
                            s[1][2] = new String("!");

                 解析：
                      s[0]=new String[2] 和 s[1]=new String[3] 是为最高维分配引用空间，也就是为最高维限制其能保存数据的最长的长度，然后再为其每个数组元素单独分配空间 s0=new String("Good") 等操作。

     
        2.多维数组的引用（以二维数组为例）

             对二维数组中的每个元素，引用方式为 arrayName[index1][index2]，例如：

                           num[1][0];


    6、Arrays 类

         java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。

          具有以下功能：

                给数组赋值：通过 fill 方法。

                对数组排序：通过 sort 方法,按升序。

                比较数组：通过 equals 方法比较数组中元素值是否相等。

                查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。


      注意：

           1、数组倒序实例：

                //倒序方法的实现
                public static int[] reverse(int[] arr){

                        int[] result = new int[arr.length];

                        for (int i = 0,j=result.length-1; i < arr.length; i++,j--) {
                            result[j] = arr[i];
                        }
                        return result;
                    }


        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

           2、// 声明二维数组：有两行，列数待定，数组结构 = { { }, { } }

                   String s[][] = new String[2][]; 

                   // 确定每行的元素个数，第一行有2个元素，第二行有3个元素，

                   // 数组结构 = {{"E1", "E2"}, {"E1", "E2", "E3"}}

                   s[0] = new String[2];

                   s[1] = new String[3];          


       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

         3、实现数组和字符串的转换处理

                public class Test {
                    public static void main(String args[]) {

                        String str = "helloworld";

                        char[] data = str.toCharArray();     // 将字符串转为数组

                        for (int x = 0; x < data.length; x++) {

                            System.out.print(data[x] + "  ");

                            data[x] -= 32;        // 单字母 小写 转 大写

                            System.out.print(data[x] + "  ");
                        }
                        System.out.println(new String(data));
                    }
                }


       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
 
        4、注意：

             String[] sr = new String[12]; //创建长度为12的字符串数组

             String[] st = {"sda","asdf"};//创建长度为2的字符串数组,并赋值

      
        
             错误实例：

                    1、  String[] sr = new String[2];
                         sr = {"sd","asd"}             //这种赋值方法是错的

             正确实例：

                     1、  String[] sr = new String[2];                 
                          sr[0] = "sd";
                          sr[1] = "sdasd";

           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

              错误实例：

                    2、 String[] str = {1,2,3,4,5};  //这样是错的， 这里的整型不会自动转为String类型


              正确实例：

                    2、String[] str = {"1","2","3","4","5"};  



       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

       5、char类型是单字符型，只能用 单引号'' 赋值，且只能赋一个单字符

		char[] c = new char[1];

		c[0] = 's';  //正确赋值

		c[0] = "s";      //错误赋值

		c[0] = "ssad";   //错误赋值

		c[0] = 'asdsd';  //错误赋值







---------------------------------------------------------------------------------------------------------------------------------------------


  十六、Java 日期时间

         java.util 包提供了 Date 类来封装当前的日期和时间。 


       1、Date 类提供两个构造函数来实例化 Date 对象


               第一个构造函数使用当前日期和时间来初始化对象。

                               Date( )

               第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。

                              Date(long millisec)



      2、Date对象创建以后，可以调用下面的方法：


          （1）boolean after(Date date)

                  若当调用此方法的Date对象在指定日期之后返回true,否则返回false。


          （2）boolean before(Date date)

                  若当调用此方法的Date对象在指定日期之前返回true,否则返回false。


          （3）Object clone( )

                  返回此对象的副本。


          （4）int compareTo(Date date)

                比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。


          （5）boolean equals(Object date)

                  当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。


          （6）long getTime( )

                  返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。


          （7）void setTime(long time)
 
                  用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期


          （8）int hashCode( )

                  返回此对象的哈希码值。


          （9）String toString( )

                  转换Date对象为String表示形式，并返回该字符串。


     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

     3、获取当前日期时间

          Java中获取当前日期和时间很简单，使用 Date 对象的 toString() 方法来打印当前日期和时间，如下所示：

              import java.util.Date;
  
              public class DateDemo {
                 public static void main(String args[]) {

                     // 初始化 Date 对象
                     Date date = new Date();
        
                     // 使用 toString() 函数显示日期时间
                     System.out.println(date.toString());
                 }
              }

             以上实例编译运行结果如下:

                    Mon May 04 09:51:52 CDT 2013


      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

     4、日期比较

          Java使用以下三种方法来比较两个日期：

            （1）使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。

            （2）使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。

            （3）使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。

    
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

     5、使用 SimpleDateFormat 格式化日期

          SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。

          例如：
          实例
          import java.util.*;
          import java.text.*;
 
          public class DateDemo {
             public static void main(String args[]) {
 
                Date dNow = new Date( );
                SimpleDateFormat ft = new SimpleDateFormat ("E yyyy.MM.dd 'at' hh:mm:ss a zzz");
 
                System.out.println("Current Date: " + ft.format(dNow));
             }


           SimpleDateFormat ft = new SimpleDateFormat ("E yyyy.MM.dd 'at' hh:mm:ss a zzz");

           这一行代码确立了转换的格式，其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。

           注意:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。

           以上实例编译运行结果如下:

                    Current Date: Sun 2014.07.18 at 14:14:09 PM PDT


     6、日期和时间的格式化编码
     
            "E yyyy-MM-dd HH:mm:ss"  ---》  星期四 2017-09-21 20:18:24

            date.toLocaleString()  ----》  2017-9-21 20:18:24
  
             ....


     7、使用printf格式化日期
              
           printf 方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 %t 开头并且以下面表格中的一个字母结尾。


            转  换  符        说    明                     示    例

               c              包括全部日期和时间信息       星期六 十月 27 14:21:20 CST 2007

               F              "年-月-日"格式               2007-10-27

               D              "月/日/年"格式               10/27/07

               r              "HH:MM:SS PM"格式（12时制）  02:25:51 下午

               T              "HH:MM:SS"格式（24时制）     14:28:16

               R              "HH:MM"格式（24时制）        14:28


              例
              import java.util.Date;
 
              public class DateDemo {
 
                public static void main(String args[]) {
                   // 初始化 Date 对象
                   Date date = new Date();
 
                   //c的使用  
                  System.out.printf("全部日期和时间信息：%tc%n",date);          
                  //f的使用  
                  System.out.printf("年-月-日格式：%tF%n",date);  
                  //d的使用  
                  System.out.printf("月/日/年格式：%tD%n",date);  
                  //r的使用  
                  System.out.printf("HH:MM:SS PM格式（12时制）：%tr%n",date);  
                  //t的使用  
                  System.out.printf("HH:MM:SS格式（24时制）：%tT%n",date);  
                  //R的使用  
                  System.out.printf("HH:MM格式（24时制）：%tR",date);  
                }
              }


    8、Java 休眠(sleep)

          sleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。


         你可以让程序休眠一毫秒的时间或者到您的计算机的寿命长的任意段时间。

         例如，下面的程序会休眠3秒：

                 import java.util.*;
  
                 public class SleepDemo {
                    public static void main(String args[]) {
                       try { 
                          System.out.println(new Date( ) + "\n"); 
                          Thread.sleep(1000*3);   // 休眠3秒
                          System.out.println(new Date( ) + "\n"); 
                       } catch (Exception e) { 
                           System.out.println("Got an exception!"); 
                       }
                    }
                 }

           以上实例编译运行结果如下:

                   Thu Sep 17 10:20:30 CST 2015

                   Thu Sep 17 10:20:33 CST 2015


     9、测量时间

             下面的一个例子表明如何测量时间间隔（以毫秒为单位）：

             实例
             import java.util.*;
             public class DiffDemo {
 
                public static void main(String args[]) {
                   try {
                      long start = System.currentTimeMillis( );
                      System.out.println(new Date( ) + "\n");
                      Thread.sleep(5*60*10);
                      System.out.println(new Date( ) + "\n");
                      long end = System.currentTimeMillis( );
                      long diff = end - start;
                      System.out.println("Difference is : " + diff);
                   } catch (Exception e) {
                      System.out.println("Got an exception!");
                   }
                }

           以上实例编译运行结果如下:

                  Fri Jan 08 09:48:47 CST 2016

                  Fri Jan 08 09:48:50 CST 2016

                  Difference is : 3019


 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      10、Calendar类
          
           我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟? 
 
           我们又如何在日期的这些部分加上或者减去值呢?

           答案是使用Calendar 类。

            Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。

            Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。


        （1）创建一个代表系统当前日期的Calendar对象

               Calendar c = Calendar.getInstance();//默认是当前日期


        （2）创建一个指定日期的Calendar对象

               使用Calendar类代表特定的时间，需要首先创建一个Calendar的对象，然后再设定该对象中的年月日参数来完成。

               //创建一个代表2009年6月12日的Calendar对象

                  Calendar c1 = Calendar.getInstance();
 
                  c1.set(2009, 6 - 1, 12);


        （3）Calendar类对象字段类型

              Calendar类中用以下这些常量表示不同的意义，jdk内的很多类其实都是采用的这种思想


                      常量	                    描述

                      Calendar.YEAR	            年份

                      Calendar.MONTH	            月份

                      Calendar.DATE	            日期

                      Calendar.DAY_OF_MONTH  	    日期，和上面的字段意义完全相同

                      Calendar.HOUR	            12小时制的小时

                      Calendar.HOUR_OF_DAY	    24小时制的小时

                      Calendar.MINUTE	            分钟

                      Calendar.SECOND	            秒

                      Calendar.DAY_OF_WEEK	    星期几


      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  

      （4）Calendar类对象信息的设置

              Calendar c1 = Calendar.getInstance();

            Set设置：     

                 调用： public final void set(int year,int month,int date) 

                          c1.set(2009, 6 - 1, 12);//把Calendar对象c1的年月日分别设这为：2009、6、12

 
                 调用：public void set(int field,int value)  //如果只设定某个字段，例如日期的值，

                         把 c1对象代表的日期设置为10号，其它所有的数值会被重新计算：

                                  c1.set(Calendar.DATE,10);

                         把c1对象代表的年份设置为2008年，其他的所有数值会被重新计算：

                                  c1.set(Calendar.YEAR,2008);

                         其他字段属性set的意义以此类推

                 ，，，，，，，，，，，，，


           Add设置：

               把c1对象的日期加上10，也就是c1也就表示为10天后的日期，其它所有的数值会被重新计算

                                c1.add(Calendar.DATE, 10);

               把c1对象的日期减去10，也就是c1也就表示为10天前的日期，其它所有的数值会被重新计算

                                c1.add(Calendar.DATE, -10);

               其他字段属性的add的意义以此类推




         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     （5）Calendar类对象信息的获得

              Calendar c1 = Calendar.getInstance();

             // 获得年份
             int year = c1.get(Calendar.YEAR);

             // 获得月份 ：
             int month = c1.get(Calendar.MONTH) + 1;   //月份值的范围为：0-11， 所以要+1

             // 获得日期
             int date = c1.get(Calendar.DATE);

             // 获得小时
             int hour = c1.get(Calendar.HOUR_OF_DAY);

             // 获得分钟
             int minute = c1.get(Calendar.MINUTE);

             // 获得秒
             int second = c1.get(Calendar.SECOND);

             // 获得星期几（注意（这个与Date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类推）
             int day = c1.get(Calendar.DAY_OF_WEEK);



 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   
  11、GregorianCalendar类  

          Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。

          Calendar 的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。

          GregorianCalendar定义了两个字段：AD和BC。这是代表公历定义的两个时代。

          .....(有很多方法)  http://www.runoob.com/java/java-date-time.html



---------------------------------------------------------------------------------------------------------------------------------------------


  十七、Java 正则表达式

         正则表达式定义了字符串的模式。

         正则表达式可以用来搜索、编辑或处理文本。

         正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。


    1、正则表达式实例

         一个字符串其实就是一个简单的正则表达式，例如 Hello World 正则表达式匹配 "Hello World" 字符串

         .（点号）也是一个正则表达式，它匹配任何一个字符如："a" 或 "1"。


         下表列出了一些正则表达式的实例及描述：

          正则表达式	                         描述

          this is text                           匹配字符串 "this is text"


          this\s+is\s+text                       注意字符串中的 \s+。

                                                 匹配单词 "this" 后面的 \s+ 可以匹配多个空格，之后匹配 is 字符串，再之后 \s+ 匹配多个空格然后                                                  再跟上 text 字符串。

                                                 可以匹配这个实例：this is text


          ^\d+(\.\d+)?                           ^ 定义了以什么开始

                                                 \d+ 匹配一个或多个数字

                                                 ? 设置括号内的选项是可选的

                                                 \. 匹配 "."

                                                 可以匹配的实例："5", "1.5" 和 "2.21"。

          Java 正则表达式和 Perl 的是最为相似的。


     2、java.util.regex 包主要包括以下三个类：

          Pattern 类：

                pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。

 
          Matcher 类：

                Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。


        PatternSyntaxException：

                PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。


      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        例子：

        以下实例中使用了正则表达式 .*runoob.* 用于查找字符串中是否包了 runoob 子串：

        import java.util.regex.*;
 
        class RegexExample1{
           public static void main(String args[]){
              String content = "I am noob " +
                "from runoob.com.";
 
              String pattern = ".*runoob.*";
 
              boolean isMatch = Pattern.matches(pattern, content);
              System.out.println("字符串中是否包含了 'runoob' 子字符串? " + isMatch);
           }
        }

       实例输出结果为：

            字符串中是否包含了 'runoob' 子字符串? true



     3、捕获组

          捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。

          例如，正则表达式 (dog) 创建了单一分组，组里包含"d"，"o"，和"g"。

          捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组：

               ((A)(B(C))) 、  (A)  、 (B(C))  、  (C)

           可以通过调用 matcher 对象的 groupCount 方法来查看表达式有多少个分组。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。
           还有一个特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupCount 的返回值中。

           .....(以后需要再学)



      4、正则表达式语法

          在其他语言中，\\ 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。

          在 Java 中，\\ 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。

          所以，在其他的语言中，一个反斜杠\就足以具有转义的作用，而在java的正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。

          也可以简单的理解在正则表达式中，两个 \ 代表其他语言中的一个 \，这也就是为什么表示一位数字的正则表达式是 \\d，而表示一个普通的反斜杠是 \\\\。

          注意：

                \   --》   将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，"n"匹配字符"n"。"\n"匹配换行符。序列"\\\\"匹                           配"\"，"\\("匹配"("。


          其他与 javaScript 类似。


      5、replaceFirst 和 replaceAll 方法

          replaceFirst 和 replaceAll 方法用来替换匹配正则表达式的文本。不同的是，replaceFirst 替换首次匹配，replaceAll 替换所有匹配。

          下面的例子来解释这个功能：

          RegexMatches.java 文件代码：

          import java.util.regex.Matcher;
          import java.util.regex.Pattern;
 
          public class RegexMatches
          {
              private static String REGEX = "dog";
              private static String INPUT = "The dog says meow. " +
                                    "All dogs say meow.";
              private static String REPLACE = "cat";
 
              public static void main(String[] args) {
                 Pattern p = Pattern.compile(REGEX);
                 // get a matcher object
                 Matcher m = p.matcher(INPUT); 
                 INPUT = m.replaceAll(REPLACE);
                 System.out.println(INPUT);
             }
          }

        以上实例编译运行结果如下：

                  The cat says meow. All cats say meow.



         （其他以后有需要再学习.....）


---------------------------------------------------------------------------------------------------------------------------------------------


  十八、Java 方法

           在前面几个章节中我们经常使用到 System.out.println()，那么它是什么呢？

                          println() 是一个方法。

                          System 是系统类。

                          out 是标准输出对象。

                          这句话的用法是调用系统类 System 中的标准输出对象 out 中的方法 println()。


           那么什么是方法呢？

                    Java方法是语句的集合，它们在一起执行一个功能。

                    方法是解决一类问题的步骤的有序组合

                    方法包含于类或对象中

                    方法在程序中被创建，在其他地方被引用


          方法的优点

                    1. 使程序变得更简短而清晰。

                    2. 有利于程序维护。

                    3. 可以提高程序开发的效率。

                    4. 提高了代码的重用性。


          方法的命名规则
 
                    1. 必须以字母、'_'或'＄'开头。

                    2. 可以包括数字，但不能以它开头。


        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
       1、方法的定义

            一般情况下，定义一个方法包含以下语法：

            修饰符 返回值类型 方法名(参数类型 参数名){
                ...
                方法体
                ...
                return 返回值;
            }

            注意： 在一些其它语言中方法指过程和函数。一个返回非void类型返回值的方法称为函数；一个返回void类型返回值的方法叫做过程。


       2、方法调用

           Java 支持两种调用方法的方式，根据方法是否返回值来选择。

           ①、当方法返回一个值的时候，方法调用通常被当做一个值。例如：

                                    int larger = max(30, 40);

           ②、如果方法返回值是void，方法调用一定是一条语句。例如，方法println返回void。下面的调用是个语句：

                                    System.out.println("欢迎访问菜鸟教程！");


        .....(中间部分省略)


       3、方法的重载

             原来的方法：

              /** 返回两个整型变量数据的较大值 */
               public static int max(int num1, int num2) {
                  int result;
                  if (num1 > num2)
                     result = num1;
                  else
                     result = num2;
 
                  return result; 
               }


             上面使用的max方法仅仅适用于int型数据。但如果你想得到两个浮点类型数据的最大值呢？

             解决方法是创建另一个有相同名字但参数不同的方法，如下面代码所示：

                    public static double max(double num1, double num2) {
                      if (num1 > num2)
                        return num1;
                      else
                        return num2;
                    }


            如果你调用max方法时传递的是int型参数，则 int型参数的max方法就会被调用；

            如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载；

            就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。

            Java编译器根据方法签名判断哪个方法应该被调用。

            方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。

            重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。



       4、变量作用域

             变量的范围是程序中该变量可以被引用的部分。

             方法内定义的变量被称为局部变量。

             局部变量的作用范围从声明开始，直到包含它的块结束。

             局部变量必须声明才可以使用。

             方法的参数范围涵盖整个方法。参数实际上是一个局部变量。

             for循环的初始化部分声明的变量，其作用范围在整个循环。
         
         注意：
               你可以在一个方法里，不同的非嵌套块中多次声明一个具有相同的名称局部变量，但你不能在嵌套块内两次声明局部变量。


      5、命令行参数的使用

           有时候你希望运行一个程序时候再传递给它消息。这要靠传递命令行参数给main()函数实现。

           命令行参数是在执行程序时候紧跟在程序名字后面的信息。

           实例
           下面的程序打印所有的命令行参数：

           CommandLine.java 文件代码：

           public class CommandLine {
              public static void main(String args[]){ 
                 for(int i=0; i<args.length; i++){
                    System.out.println("args[" + i + "]: " +
                                                      args[i]);
                 }
              }
           }


          如下所示，运行这个程序：

             $ javac CommandLine.java 
             $ java CommandLine this is a command line 200 -100
             args[0]: this
             args[1]: is
             args[2]: a
             args[3]: command
             args[4]: line
             args[5]: 200
             args[6]: -100



      6、构造方法

           当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。

           通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。

           不管你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，它把所有成员初始化为0。

           一旦你定义了自己的构造方法，默认构造方法就会失效。

           实例
           下面是一个使用构造方法的例子：
           // 一个简单的构造函数
           class MyClass {
             int x;
 
             // 以下是构造函数
             MyClass() {
               x = 10;
             }
           }



      7、可变参数

          JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。

          方法的可变参数的声明如下所示：

                     typeName... parameterName

          在方法声明中，在指定参数类型后加一个省略号(...) 。

          一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。

          实例
          VarargsDemo.java 文件代码：
          public class VarargsDemo {
              public static void main(String args[]) {
                  // 调用可变参数的方法
                  printMax(34, 3, 3, 2, 56.5);
                  printMax(new double[]{1, 2, 3});
              }
 
              public static void printMax( double... numbers) {
                  if (numbers.length == 0) {
                      System.out.println("No argument passed");
                      return;
                  }
 
                  double result = numbers[0];
 
                  for (int i = 1; i <  numbers.length; i++){
                      if (numbers[i] >  result) {
                          result = numbers[i];
                      }
                  }
                  System.out.println("The max value is " + result);
              }
          }

          以上实例编译运行结果如下：

                The max value is 56.5
                The max value is 3.0



      8、finalize() 方法

           Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。

           例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。

           在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。

           finalize() 一般格式是：

                            protected void finalize()
                            {
                               // 在这里终结代码
                            }


        关键字 protected 是一个限定符，它确保 finalize() 方法不会被该类以外的代码调用。

        当然，Java 的内存回收可以由 JVM 来自动完成。如果你手动使用，则可以使用上面的方法。

        实例
        FinalizationDemo.java 文件代码：
        public class FinalizationDemo {  
          public static void main(String[] args) {  
            Cake c1 = new Cake(1);  
            Cake c2 = new Cake(2);  
            Cake c3 = new Cake(3);  
      
            c2 = c3 = null;  
            System.gc(); //调用Java垃圾收集器
          }  
        }  
 
        class Cake extends Object {  
          private int id;  
          public Cake(int id) {  
            this.id = id;  
            System.out.println("Cake Object " + id + "is created");  
          }  
    
          protected void finalize() throws java.lang.Throwable {  
            super.finalize();  
            System.out.println("Cake Object " + id + "is disposed");  
          }  
        }

       运行以上代码，输出结果如下：

            $ javac FinalizationDemo.java 
            $ java FinalizationDemo
            Cake Object 1is created
            Cake Object 2is created
            Cake Object 3is created
            Cake Object 3is disposed
            Cake Object 2is disposed


---------------------------------------------------------------------------------------------------------------------------------------------


  十九、Java 流(Stream)、文件(File)和IO

           Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。

           Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。

           一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。

          Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。

          但本节讲述最基本的和流与 I/O 相关的功能。我们将通过一个个例子来学习这些功能。
   

      1、读取控制台输入

           Java 的控制台输入由 System.in 完成。

           为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。

           下面是创建 BufferedReader 的基本语法：

                  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

                  String str = br.readLine();
                  //String str = br.read();

           BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。


  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      2、从控制台读取多字符输入

            从 BufferedReader 对象读取一个字符要使用 read() 方法，它的语法如下：

                             int read( ) throws IOException

           每次调用 read() 方法，它从输入流读取一个字符并把该字符作为整数值返回。 当流结束的时候返回 -1。该方法抛出 IOException。


下面的程序示范了用 read() 方法从控制台不断读取字符直到用户输入 "q"。
BRRead.java 文件代码：
// 使用 BufferedReader 在控制台读取字符
 
import java.io.*;
 
public class BRRead {
  public static void main(String args[]) throws IOException
  {
    char c;
    // 使用 System.in 创建 BufferedReader 
    BufferedReader br = new BufferedReader(new 
                       InputStreamReader(System.in));
    System.out.println("输入字符, 按下 'q' 键退出。");
    // 读取字符
    do {
       c = (char) br.read();
       System.out.println(c);
    } while(c != 'q');
  }
}

以上实例编译运行结果如下:
输入字符, 按下 'q' 键退出。
runoob
r
u
n
o
o
b


q
q


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   3、从控制台读取字符串

        从标准输入读取一个字符串需要使用 BufferedReader 的 readLine() 方法。

        它的一般格式是：
                       String readLine( ) throws IOException


下面的程序读取和显示字符行直到你输入了单词"end"。
BRReadLines.java 文件代码：
// 使用 BufferedReader 在控制台读取字符
import java.io.*;
public class BRReadLines {
  public static void main(String args[]) throws IOException
  {
    // 使用 System.in 创建 BufferedReader 
    BufferedReader br = new BufferedReader(new
                            InputStreamReader(System.in));
    String str;
    System.out.println("Enter lines of text.");
    System.out.println("Enter 'end' to quit.");
    do {
       str = br.readLine();
       System.out.println(str);
    } while(!str.equals("end"));
  }
}

以上实例编译运行结果如下:

Enter lines of text.
Enter 'end' to quit.
This is line one
This is line one
This is line two
This is line two
end
end

  JDK 5 后的版本我们也可以使用 Java Scanner 类来获取控制台的输入。

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  注意： 
          java中br.readLine与 br.read的用法区别：

               read方法功能：读取单个字符。 返回：作为一个整数（其范围从 0 到 65535 (0x00-0xffff)）读入的字符，如果已到达流末尾，则返回 -1 

               readLine方法功能：读取一个文本行。通过下列字符之一即可认为某行已终止：换行 ('\n')、回车 ('\r') 或回车后直接跟着换行。 返回：包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null
 

              char str = (char) br.read();  // read（）返回的是一个int类型的值，需要把它转为char类型

              当输入"abcd"时，br.read() 只能得到"a",读取单个字符, 要读取全部字符，要用到while循环。


              br.readLine（）//返回的是一个String类型的字符串


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   4、控制台输出

        在此前已经介绍过，控制台的输出由 print( ) 和 println() 完成。这些方法都由类 PrintStream 定义，System.out 是该类对象的一个引用。
         
        PrintStream 继承了 OutputStream类，并且实现了方法 write()。这样，write() 也可以用来往控制台写操作。

        PrintStream 定义 write() 的最简单格式如下所示：

                                      void write(int byteval)
          
          该方法将 byteval 的低八位字节写到流中。


          实例
          下面的例子用 write() 把字符 "A" 和紧跟着的换行符输出到屏幕：
          WriteDemo.java 文件代码：
          import java.io.*;
 
          // 演示 System.out.write().
          public class WriteDemo {
             public static void main(String args[]) {
                int b; 
                b = 'A';
                System.out.write(b);
                System.out.write('\n');
             }
          }

          运行以上实例在输出窗口输出 "A" 字符

          注意：write() 方法不经常使用，因为 print() 和 println() 方法用起来更为方便。  《-----




   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    5、读写文件

         如前所述，一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。

         下图是一个描述输入流和输出流的类层次图 ： E:\课堂\IO流.png
 
         下面将要讨论的两个重要的流是 FileInputStream 和 FileOutputStream：
       

      （1）FileInputStream

            该流用于从文件读取数据，它的对象可以用关键字 new 来创建。

            有多种构造方法可用来创建对象。

            可以使用字符串类型的文件名来创建一个输入流对象来读取文件：

                  InputStream f = new FileInputStream("C:/java/hello");

            也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象：

                  File f = new File("C:/java/hello");

                  InputStream out = new FileInputStream(f);

            创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。


             ①、public void close() throws IOException{}

                      关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。


             ②、protected void finalize()throws IOException {}

                      这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。


             ③、public int read(int r)throws IOException{}

                      这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。


             ④、public int read(byte[] r) throws IOException{}

                      这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。


             ⑤、public int available() throws IOException{}   //返回 文本有多少字节数可以被读取。--》可以创建相应大小的 char[]数组

                      返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。


      （2）、FileOutputStream

              该类用来创建一个文件并向文件中写数据。

              如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。

              有两个构造方法可以用来创建 FileOutputStream 对象。


              使用字符串类型的文件名来创建一个输出流对象：

                  OutputStream f = new FileOutputStream("C:/java/hello")

              也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：

                  File f = new File("C:/java/hello");

                  OutputStream f = new FileOutputStream(f);

             创建OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。


               ①、public void close() throws IOException{}
  
                     关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。


               ②、protected void finalize()throws IOException {}

                     这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。


               ③、public void write(int w)throws IOException{}

                     这个方法把指定的字节写到输出流中。


               ④、public void write(byte[] w)

                     把指定数组中w.length长度的字节写到OutputStream中。


               除了OutputStream外，还有一些其他的输出流，更多的细节参考下面链接：

                    ByteArrayOutputStream

                    DataOutputStream


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

实例

下面是一个演示 InputStream 和 OutputStream 用法的例子：

fileStreamTest.java 文件代码：

import java.io.*;
 
public class fileStreamTest{
  public static void main(String args[]){
    try{
      byte bWrite [] = {11,21,3,40,5};
      OutputStream os = new FileOutputStream("test.txt");
      for(int x=0; x < bWrite.length ; x++){
      os.write( bWrite[x] ); // writes the bytes
    }
    os.close();
 
    InputStream is = new FileInputStream("test.txt");

    int size = is.available(); //判断文本中有多少字节数可以被读取
 
    for(int i=0; i< size; i++){
      System.out.print((char)is.read() + "  ");
    }
      is.close();
    }catch(IOException e){
      System.out.print("Exception");
    }  
  }
}
上面的程序首先创建文件test.txt，并把给定的数字以二进制形式写进该文件，同时输出到控制台上。


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


以上代码由于是二进制写入，可能存在乱码，你可以使用以下代码实例来解决乱码问题：

fileStreamTest2.java 文件代码：

//文件名 :fileStreamTest2.java

import java.io.*;
 
public class fileStreamTest2{
  public static void main(String[] args) throws IOException {
    
    File f = new File("a.txt");
    FileOutputStream fop = new FileOutputStream(f);
    // 构建FileOutputStream对象,文件不存在会自动新建
    
    OutputStreamWriter writer = new OutputStreamWriter(fop, "UTF-8");
    // 构建OutputStreamWriter对象,参数可以指定编码,默认为操作系统默认编码,windows上是gbk
    
    writer.append("中文输入");
    // 写入到缓冲区
    
    writer.append("\r\n");
    //换行
    
    writer.append("English");
    // 刷新缓存冲,写入到文件,如果下面已经没有写入的内容了,直接close也会写入
    
    writer.close();
    // 关闭写入流,同时会把缓冲区内容写入文件,所以上面的注释掉
    
    fop.close();
    // 关闭输出流,释放系统资源
 
    FileInputStream fip = new FileInputStream(f);
    // 构建FileInputStream对象
    
    InputStreamReader reader = new InputStreamReader(fip, "UTF-8");
    // 构建InputStreamReader对象,编码与写入相同
 
    StringBuffer sb = new StringBuffer();   //可以用StringBuffer 和 StringBuilder 的append（）来拼接单字符char类型的字符

    while (reader.ready()) {

    sb.append((char) reader.read());
    // 转成char加到StringBuffer对象中

    }

    System.out.println(sb.toString());
    reader.close();
    // 关闭读取流
    
    fip.close();
    // 关闭输入流,释放系统资源
 
  }
}




~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

下面的示例演示java.io.InputStreamReader.ready()方法的用法。

   public static void main(String[] args) throws IOException {
       
      FileInputStream fis = null;
      InputStreamReader isr =null;
      boolean bool = false;
      int i;
      char c;
       
      try {
         // new input stream reader is created 
         fis = new FileInputStream("C:/test.txt");
         isr = new InputStreamReader(fis);
          
         // reads into the char buffer
         while((i=isr.read())!=-1)
         {
            // converts int to char
            c=(char)i;
             
            // prints the character
            System.out.println("Character read: "+c);
             
            // true if the next read is guaranteed
            bool = isr.ready();
             
            // prints
            System.out.println("Ready to read: "+bool);
         }
      } catch (Exception e) {
       
         // print error
         e.printStackTrace();
      } finally {
          
         // closes the stream and releases resources associated
         if(fis!=null)
            fis.close();
         if(isr!=null)
            isr.close();
      }   
   }}


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`

注意：

      从以上例子中，可知有两种方法判断 whlie循环 结束：

      1、read()==-1

         while((i=isr.read())!=-1)
         {
            // converts int to char
            c=(char)i;
             
            // prints the character
            System.out.println("Character read: "+c);
             
            // true if the next read is guaranteed
            bool = isr.ready();
             
            // prints
            System.out.println("Ready to read: "+bool);
         }


     2、reader.ready()==false

    while (reader.ready()) {

    sb.append((char) reader.read());
    // 转成char加到StringBuffer对象中

    }


  //java.io.InputStreamReader.ready() 方法通知此流是否已准备好被读取。

  //返回值： 如果下一读取保证不会阻塞输入，该方法返回true，否则返回false。




~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   (3)文件和I/O

        还有一些关于文件和I/O的类，我们也需要知道：

            File Class(类)

            FileReader Class(类)

            FileWriter Class(类)


        Java中的目录  

 
          创建目录： mkdir( )  mkdirs()

            File类中有两个方法可以用来创建文件夹：

            mkdir( )方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。

            mkdirs()方法创建一个文件夹和它的所有父文件夹。

           
            下面的例子创建 "/tmp/user/java/bin"文件夹：

            CreateDir.java 文件代码：

            import java.io.File;
 
            public class CreateDir {

              public static void main(String args[]) {

                String dirname = "/tmp/user/java/bin";

                File d = new File(dirname);
                // 现在创建目录
                d.mkdirs();
              }
            }


        编译并执行上面代码来创建目录 "/tmp/user/java/bin"。

        注意： Java 在 UNIX 和 Windows 自动按约定分辨文件路径分隔符。如果你在 Windows 版本的 Java 中使用分隔符 (/) ，路径依然能够被正确解析。


   (4)读取目录   isDirectory()  list() 方法
 
        一个目录其实就是一个 File 对象，它包含其他文件和文件夹。

        如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。

        可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。

        下面展示的例子说明如何使用 list() 方法来检查一个文件夹中包含的内容：

         DirList.java 文件代码：
         import java.io.File;
 
         public class DirList {
           public static void main(String args[]) {

             String dirname = "/tmp";
             File f1 = new File(dirname);

             if (f1.isDirectory()) {
               System.out.println( "目录 " + dirname);
               String s[] = f1.list();
               for (int i=0; i < s.length; i++) {

                 File f = new File(dirname + "/" + s[i]);

                 if (f.isDirectory()) {

                   System.out.println(s[i] + " 是一个目录");

                 } else {
                   System.out.println(s[i] + " 是一个文件");
                 }
               }
             } else {
               System.out.println(dirname + " 不是一个目录");
             }
           }
         }

        以上实例编译运行结果如下：

             目录 /tmp
             bin 是一个目录
             lib 是一个目录
             demo 是一个目录
             test.txt 是一个文件
             README 是一个文件
             index.html 是一个文件
             include 是一个目录



    (5)、删除目录或文件  java.io.File.delete() 

          删除文件可以使用 java.io.File.delete() 方法。

          以下代码会删除目录/tmp/java/，即便目录不为空。

            测试目录结构：

                    /tmp/java/
                    |-- 1.log
                    |-- test


            DeleteFileDemo.java 文件代码：
            import java.io.File;
 
            public class DeleteFileDemo {
              public static void main(String args[]) {
                  // 这里修改为自己的测试目录
                File folder = new File("/tmp/java/");
                deleteFolder(folder);
              }
 
              //删除文件及目录
              public static void deleteFolder(File folder) {

                File[] files = folder.listFiles();

                    if(files!=null) { 
                        for(File f: files) {

                            if(f.isDirectory()) {   //判断是否是文件夹，若是文件夹，则递归deleteFolder（）
                                deleteFolder(f);

                            } else {
                                f.delete();
                            }
                        }
                    }
                    folder.delete();
                }
            }


       注意：
              folder.list() 和 folder.listFiles() 的区别：
 
              1、list() 取的是folder文件夹下所有 文件 和 文件夹 的名称， 返回的是一个String类型的数组

              2、listFiles()取的是folder文件夹下所有 文件 和 文件夹 的file对象, 返回的是一个 存file对象 的数组




---------------------------------------------------------------------------------------------------------------------------------------------


   二十、Java Scanner 类

           java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。

             BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

           下面是创建 Scanner 对象的基本语法：

                   Scanner s = new Scanner(System.in);

          接下来我们演示一个最简单的的数据输入，并通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，

          在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据：
      

         (1)使用 next 方法：   scan.hasNext() // 判断是否还有输入

                ScannerDemo.java 文件代码：
                import java.util.Scanner; 
 
                public class ScannerDemo {  
                    public static void main(String[] args) {  

                        Scanner scan = new Scanner(System.in); 
                    // 从键盘接收数据  
 
                    //next方式接收字符串
                        System.out.println("next方式接收：");

                        // 判断是否还有输入
                        if(scan.hasNext()){   
                          String str1 = scan.next();
                          System.out.println("输入的数据为："+str1);  
                        }   
                    }  
                }

                 执行以上程序输出结果为：

                     $ javac ScannerDemo.java
                     $ java ScannerDemo
                     next方式接收：
                     runoob com
                     输入的数据为：runoob

                     可以看到 com 字符串并未输出，接下来我们看 nextLine。


      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

          (2)、使用 nextLine 方法：      scan.hasNextLine()//// 判断是否还有输入

                   ScannerDemo.java 文件代码：
                   import java.util.Scanner; 
 
                   public class ScannerDemo {  
                       public static void main(String[] args) {  

                           Scanner scan = new Scanner(System.in); 
                       // 从键盘接收数据  
 
                       //nextLine方式接收字符串
                           System.out.println("nextLine方式接收：");

                           // 判断是否还有输入
                           if(scan.hasNextLine()){  
 
                             String str2 = scan.nextLine();
                             System.out.println("输入的数据为："+str2);  
                           }  
                       }  
                   }


                  执行以上程序输出结果为：

                           $ javac ScannerDemo.java
                           $ java ScannerDemo
                           nextLine方式接收：
                           runoob com
                           输入的数据为：runoob com

                        可以看到 com 字符串输出。



    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


         （3）、next() 与 nextLine() 区别

                  next():

                       1、一定要读取到有效字符后才可以结束输入。

                       2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。

                       3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。

                       next() 不能得到带有空格的字符串。

                  nextLine()：

                       1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。

                       2、可以获得空白。


       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`

         （4）、如果要输入 int 或 float 类型的数据，在 Scanner 类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取：



                  ScannerDemo.java 文件代码：
                  import java.util.Scanner;  
 
                  public class ScannerDemo {  

                      public static void main(String[] args) {  

                          Scanner scan = new Scanner(System.in);  
                      // 从键盘接收数据  
                          int i = 0 ;  
                          float f = 0.0f ;  
                          System.out.print("输入整数：");  

                          if(scan.hasNextInt()){       //   scan.hasNextInt() ：判断输入的是否是整数      
                        // 判断输入的是否是整数  
                              i = scan.nextInt() ;     //     scan.nextInt() ： 得到输入的整数            
                        // 接收整数  
                              System.out.println("整数数据：" + i) ;  
                          }else{                                 
                        // 输入错误的信息  
                              System.out.println("输入的不是整数！") ;  
                          }  
                          System.out.print("输入小数：");  

                          if(scan.hasNextFloat()){     //   scan.hasNextFloat() ： 判断输入的是否是小数      
                        // 判断输入的是否是小数  
                              f = scan.nextFloat() ;   //   scan.nextFloat() ：   接收小数      
                        // 接收小数  
                              System.out.println("小数数据：" + f) ;  
                          }else{                                
                        // 输入错误的信息  
                              System.out.println("输入的不是小数！") ;  
                          }  
                      }  
                  }


                   执行以上程序输出结果为：

                               $ javac ScannerDemo.java
                               $ java ScannerDemo
                               输入整数：12
                               整数数据：12
                               输入小数：1.2
                               小数数据：1.2


           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        (5)、以下实例我们可以输入多个数字，并求其总和与平均数，每输入一个数字用回车确认，

             通过输入非数字来结束输入并输出执行结果：

                       ScannerDemo.java 文件代码：
                       import java.util.Scanner; 
 
                       class ScannerDemo   
                       {  
                           public static void main(String[] args)   
                           {  
                               Scanner scan = new Scanner(System.in);  
  
                               double sum = 0;  
                               int m = 0;  
  
                               while(scan.hasNextDouble())  
                               {  
                                   double x = scan.nextDouble();  
                                   m = m + 1;  
                                   sum = sum + x;  
                               }  
  
                               System.out.println(m+"个数的和为"+sum);  
                               System.out.println(m+"个数的平均值是"+(sum/m));  
                           }  
                       }

                  执行以上程序输出结果为：

                             $ javac ScannerDemo.java
                             $ java ScannerDemo
                             12
                             23
                             15
                             21.4
                             end
                             4个数的和为71.4
                             4个数的平均值是17.85


---------------------------------------------------------------------------------------------------------------------------------------------


   二十一、Java 异常处理


      异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。

      比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error；

      如果你用System.out.println(11/0)，那么你是因为你用0做了除数，会抛出 java.lang.ArithmeticException 的异常。

      异常发生的原因有很多，通常包含以下几大类：

                       用户输入了非法数据。

                       要打开的文件不存在。

                       网络通信时连接中断，或者JVM内存溢出。


     这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。-

     要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：

       （1）、检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。
 
       （2）、运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。

       （3）、错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。

   
   1、Exception 类的层次

       所有的异常类是从 java.lang.Exception 类继承的子类。

       Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。

       Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。

       Error 用来指示运行时环境发生的错误。
      
               例如，JVM 内存溢出。一般地，程序不会从错误中恢复。


       异常类有两个主要的子类：IOException 类和 RuntimeException 类。

       在 Java 内置类中(接下来会说明)，有大部分常用检查性和非检查性异常。


                    Throwable 
                 。          。
               。              。
            Error               Exception
                               。      。
                              。        。
                       IOException     RuntimeException 


    2、Java 内置异常类

         Java 语言定义了一些异常类在 java.lang 标准包中。

         标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。


      （1）Java 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常:


              ArithmeticException	        当出现异常的运算条件时，抛出此异常。例如，一个整数"除以零"时，抛出此类的一个实例。

              ArrayIndexOutOfBoundsException	用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。

              ClassCastException	        当试图将对象强制转换为不是实例的子类时，抛出该异常。

              IllegalArgumentException	        抛出的异常表明向方法传递了一个不合法或不正确的参数。
 
              ...


      （2）下面的表中列出了 Java 定义在 java.lang 包中的检查性异常类:


             ClassNotFoundException	   应用程序试图加载类时，找不到相应的类，抛出该异常。

             CloneNotSupportedException	   当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。

             IllegalAccessException	   拒绝访问一个类的时候，抛出该异常。

             InstantiationException	   当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象                                           类而无法实例化时，抛出该异常。

             InterruptedException	   一个线程被另一个线程中断，抛出该异常。

             NoSuchFieldException	   请求的变量不存在

             NoSuchMethodException	   请求的方法不存在



     3、异常方法

           下面的列表是 Throwable 类的主要方法:

               1、public String getMessage()

                           返回关于发生的异常的详细信息。这个消息在 Throwable 类的构造函数中初始化了。

               2、public Throwable getCause()

                           返回一个Throwable 对象代表异常原因。

               3、public String toString()

                           使用getMessage()的结果返回类的串级名字。

               4、public void printStackTrace()

                           打印toString()结果和栈层次到System.err，即错误输出流。

               5、public StackTraceElement [] getStackTrace()

                           返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。

               6、public Throwable fillInStackTrace()

                           用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。


    4、捕获异常

           使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。

             try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：

                      try
                      {
                         // 程序代码

                      }catch(ExceptionName e1)
                      {
                         //Catch 块
                      }


          Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。

          如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。

实例

下面的例子中声明有两个元素的一个数组，当代码试图访问数组的第三个元素的时候就会抛出一个异常。
ExcepTest.java 文件代码：
// 文件名 : ExcepTest.java
import java.io.*;
public class ExcepTest{
 
   public static void main(String args[]){
      try{
         int a[] = new int[2];
         System.out.println("Access element three :" + a[3]);
      }catch(ArrayIndexOutOfBoundsException e){
         System.out.println("Exception thrown  :" + e);
      }
      System.out.println("Out of the block");
   }
}

以上代码编译运行输出结果如下：

Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3
Out of the block



   5、多重捕获块

         一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。

             多重捕获块的语法如下所示：

                      try{

                         // 程序代码

                      }catch(异常类型1 异常的变量名1){

                        // 程序代码

                      }catch(异常类型2 异常的变量名2){

                        // 程序代码

                      }catch(异常类型2 异常的变量名2){

                        // 程序代码
                      }

               上面的代码段包含了 3 个 catch块。

                      可以在 try 语句后面添加任意数量的 catch 块。

                      如果保护代码中发生异常，异常被抛给第一个 catch 块。

                      如果抛出异常的数据类型与 ExceptionType1 匹配，它在这里就会被捕获。

                      如果不匹配，它会被传递给第二个 catch 块。

                      如此，直到异常被捕获或者通过所有的 catch 块。



    6、throws/throw 关键字：

          如果一个方法没有捕获一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。

          也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。

             下面方法的声明抛出一个 RemoteException 异常：

                        import java.io.*;
                        public class className
                        {
                          public void deposit(double amount) throws RemoteException
                          {
                            // Method implementation
                            throw new RemoteException();
                          }
                          //Remainder of class definition
                        }

            一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。

               例如，下面的方法声明抛出 RemoteException 和 InsufficientFundsException：
 
                      import java.io.*;
                      public class className
                      {
                         public void withdraw(double amount) throws RemoteException,
                                                    InsufficientFundsException
                         {
                             // Method implementation
                         }
                         //Remainder of class definition
                      }


    7、finally关键字

         finally 关键字用来创建在 try 代码块后面执行的代码块。

         无论是否发生异常，finally 代码块中的代码总会被执行。

         在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。

         finally 代码块出现在 catch 代码块最后，语法如下：

            try{

              // 程序代码

            }catch(异常类型1 异常的变量名1){

              // 程序代码

            }catch(异常类型2 异常的变量名2){

              // 程序代码

            }finally{

              // 程序代码

            }


       注意下面事项：

           catch 不能独立于 try 存在。

           在 try/catch 后面添加 finally 块并非强制性要求的。

           try 代码后不能既没 catch 块也没 finally 块。

           try, catch, finally 块之间不能添加任何代码。



     8、声明自定义异常

         在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。

               所有异常都必须是 Throwable 的子类。

               如果希望写一个检查性异常类，则需要继承 Exception 类。

               如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。

          可以像下面这样定义自己的异常类：

           ①   class MyException extends Exception{
              }


           ②  throw new MyException(needs);
       
           ③ try
                {
        
               }catch(InsufficientFundsException e)
               {
        
                  e.printStackTrace();
               }

          具体例子：http://www.runoob.com/java/java-exceptions.html



      9、通用异常

          在Java中定义了两种类型的异常和错误。

             1. JVM(Java虚拟机) 异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。


             2. 程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
   名词解释：

           1、检查性异常: 不处理编译不能通过

           2、非检查性异常:不处理编译可以通过，如果有抛出直接抛到控制台

           3、运行时异常: 就是非检查性异常

           4、非运行时异常: 就是检查性异常


  异常使用可遵循下面的原则：

           1：在当前方法被覆盖时，覆盖他的方法必须抛出相同的异常或异常的子类；

           2：在当前方法声明中使用try-catch语句捕获异常；

           3：如果父类抛出多个异常，则覆盖方法必须抛出那些异常的一个子集，不能抛出新异常。


  printStackTrace()方法的意思是：

                  在命令行打印异常信息在程序中出错的位置及原因。

                  只要记住这是对虚拟机内部的错误信息的提交并显示到前台的人机交换的机制就行了。




---------------------------------------------------------------------------------------------------------------------------------------------


 第二大部分  Java 面向对象


  二十二、Java 继承

     继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。

     继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

     生活中的继承：

                  兔子和羊属于食草动物类，狮子和豹属于食肉动物类。

                  食草动物和食肉动物又是属于动物类。

     所以继承需要符合的关系是：is-a，父类更通用，子类更具体。

     虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以子类会具有父类的一般特性也会具有自身的特性。


     1、类的继承格式

         在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：

           类的继承格式
           class 父类 {
           }
 
           class 子类 extends 父类 {
           }



    2、从这两段代码可以看出来，代码存在重复了，导致后果就是代码量大且臃肿，而且维护性不高(维护性主要是后期需要修改的时候，就需要修改很多的代码，容易出错)，所以要从根本上解决这两段代码的问题，就需要继承，


公共父类：
public class Animal { 
    private String name;  
    private int id; 
    public Animal(String myName, int myid) { 
        name = myName; 
        id = myid;
    } 
    public void eat(){ 
        System.out.println(name+"正在吃"); 
    }
    public void sleep(){
        System.out.println(name+"正在睡");
    }
    public void introduction() { 
        System.out.println("大家好！我是" + id + "号" + name + "."); 
    } 
}

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

       老鼠类：
          public class Mouse extends Animal { 
              public Mouse(String myName, int myid) { 

                  super(myName, myid);    //这里利用super(参数，参数),调用了父类的有参数的构造函数

              } 
          }


    3、继承的特性

         子类拥有父类非private的属性，方法。

         子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。

         子类可以用自己的方式实现父类的方法。

         Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，

              多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。

         提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。



    4、继承关键字

          继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，

          当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。


        (1)extends关键字

            在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。

        (2)implements关键字

            使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。


       (3)super 与 this 关键字

           super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。

           this关键字：指向自己的引用。
        

       (4)final关键字

         final 类:     final 关键字声明类可以把类定义为不能继承的，即最终类；

         fianl 方法：  或者用于修饰方法，该方法不能被子类重写：


         声明类：
                 final class 类名 {//类体}


        声明方法：

                 修饰符(public/private/default/protected) final 返回值类型 方法名(){//方法体}


        注:实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final




    5、构造器

         子类不能继承父类的构造器（构造方法或者构造函数），但是父类的构造器带有参数的，则必须在子类的构造器中显式地通过super关键字调用父类的构造器并配以适当的参数列表。
 
         如果父类有无参构造器，则在子类的构造器中用super调用父类构造器不是必须的，如果没有使用super关键字，系统会自动调用父类的无参构造器。


实例
class SuperClass {
  private int n;
  SuperClass(){
    System.out.println("SuperClass()");
  }
  SuperClass(int n) {
    System.out.println("SuperClass(int n)");
    this.n = n;
  }
}
class SubClass extends SuperClass{
  private int n;
  
  SubClass(){
    super(300);
    System.out.println("SubClass");
  }  
  
  public SubClass(int n){
    System.out.println("SubClass(int n):"+n);
    this.n = n;
  }
}
public class TestSuperSub{
  public static void main (String args[]){
    SubClass sc = new SubClass();
    SubClass sc2 = new SubClass(200); 
  }
}


输出结果为：
SuperClass(int n)
SubClass
SuperClass()           //注意： 当在子类的构造器中没有使用super关键字时，系统会自动调用父类的无参构造器super()（前提：当父类有无参构造器）。
SubClass(int n):200

                       //注意：但父类只有带参数的构造器时，在子类的构造器中必须显式地通过super关键字调用父类的构造器并配以适当的参数列表。



   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 注意：

     1、继承是 Java 中实现软件重用的重要手段，避免重复，易于维护，易于理解。

     2、继承的注意点：

            子类不是父类的子集，子类一般比父类包含更多的数据域和方法。

            父类中的 private 数据域在子类中是不可见的，因此在子类中不能直接使用它们。可以通过getter 和 setter 使用

            继承是为 "是一个" 的关系建模的，父类和其子类间必须存在 "是一个" 的关系，否则不能用继承。

                 但也并不是所有"是一个"的关系都应该用继承。

                 例如，正方形是一个矩形，但不能让 Square 类来继承 Rectangle 类，因为正方形不能从矩形扩展得到任何东西。

                 正确的继承关系是 Square 类继承 Shape 类
 
           Java 只允许单一继承（即一个子类只能有一个直接父类），C++ 可以多重继承（即一个子类有多个直接父类）。


     3、super 表示使用它的类的父类。super 可用于：
 
                  调用父类的构造方法：

                            super();  或    super(参数列表);

                  调用父类的方法（子类覆盖了父类的方法时）；

                  访问父类的数据域（可以这样用但没有必要这样用）。

           注意：super 语句必须是子类构造方法的第一条语句。作为子类构造方法的第一条语句。这会形成一个构造方法链。

                 调用父类的构造方法的唯一途径是使用 super 关键字，如果子类中没显式调用，则编译器自动将 super();

                 静态方法中不能使用 super 关键字。

                 调用父类的方法语法：

                             super.方法名(参数列表);
 

    4、this 关键字

          this 关键字表示当前对象。可用于：

              调用当前类的构造方法，并且必须是方法的第一条语句。如：this(); 调用默认构造方法。this(参数); 调用带参构造方法。

              限定当前对象的数据域变量。一般用于方法内的局部变量与对象的数据域变量同名的情况。如 this.num = num。this.num 表示当前对象的数据域变量 num，而 num 表示方法中的局部变量。




---------------------------------------------------------------------------------------------------------------------------------------------



  二十三、Java 重写(Override)与重载(Overload)


     1、重写(Override) ---> 外壳不变，核心重写

          重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
 
          重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。

          重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。

                例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，

                       因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。

          在面向对象原则里，重写意味着可以重写任何现有方法。

实例如下：

TestDog.java 文件代码：
class Animal{
   public void move(){
      System.out.println("动物可以移动");
   }
}
 
class Dog extends Animal{
   public void move(){
      System.out.println("狗可以跑和走");
   }
}
 
public class TestDog{
   public static void main(String args[]){

      Animal a = new Animal(); // Animal 对象

      Animal b = new Dog(); // Dog 对象  //尽管b属于Animal类型，但是它运行的是Dog类的move方法。
 
      a.move();// 执行 Animal 类的方法
 
      b.move();//执行 Dog 类的方法
   }
}

以上实例编译运行结果如下：

动物可以移动
狗可以跑和走


解析：

       在上面的例子中可以看到，尽管b属于Animal类型，但是它运行的是Dog类的move方法。

       这是由于在编译阶段，只是检查参数的引用类型。

       然而在运行时，Java虚拟机(JVM)指定对象的类型并且运行该对象的方法。

       因此在上面的例子中，之所以能编译成功，是因为Animal类中存在move方法，然而运行时，运行的是特定对象的方法。


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

思考以下例子：
TestDog.java 文件代码：
class Animal{
   public void move(){
      System.out.println("动物可以移动");
   }
}
 
class Dog extends Animal{
   public void move(){
      System.out.println("狗可以跑和走");
   }
   public void bark(){
      System.out.println("狗可以吠叫");
   }
}
 
public class TestDog{
   public static void main(String args[]){
      Animal a = new Animal(); // Animal 对象
      Animal b = new Dog(); // Dog 对象
 
      a.move();// 执行 Animal 类的方法

      b.move();//执行 Dog 类的方法

      b.bark();     --------------------------> //该程序将抛出一个编译错误，因为b的引用类型Animal没有bark方法。
   }
}

以上实例编译运行结果如下：

TestDog.java:30: cannot find symbol
symbol  : method bark()
location: class Animal
                b.bark();
                 ^

该程序将抛出一个编译错误，因为b的引用类型Animal没有bark方法。


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  2、方法的重写规则

      参数列表必须完全与被重写方法的相同；

      返回类型必须完全与被重写方法的返回类型相同；

      访问权限不能比父类中被重写的方法的访问权限更低。

                    例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。

      父类的成员方法只能被它的子类重写。

      声明为final的方法不能被重写。

      声明为static的方法不能被重写，但是能够被再次声明。

      子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。

      子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。

      重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
    
      构造方法不能被重写。

      如果不能继承一个方法，则不能重写这个方法。
 

   3、Super关键字的使用

       当需要在子类中调用父类的被重写方法时，要使用super关键字。

           class Dog extends Animal{

              public void move(){
                 super.move(); // 应用super类的方法
                 System.out.println("狗可以跑和走");
              }
           }

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   4、重载(Overload) ----》方法能够在同一个类中或者在一个子类中被重载

       重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。

       每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

       最常用的地方就是构造器的重载。


       重载规则：

                   被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；

                   重载的方法可以改变返回类型；

                   被重载的方法可以改变访问修饰符；

                   被重载的方法可以声明新的或更广的检查异常；

                   方法能够在同一个类中或者在一个子类中被重载。

                   无法以返回值类型作为重载函数的区分标准。


实例
Overloading.java 文件代码：
public class Overloading {
    public int test(){
        System.out.println("test1");
        return 1;
    }
 
    public void test(int a){
        System.out.println("test2");
    }   
 
    //以下两个参数类型顺序不同
    public String test(int a,String s){
        System.out.println("test3");
        return "returntest3";
    }   
 
    public String test(String s,int a){
        System.out.println("test4");
        return "returntest4";
    }   
 
    public static void main(String[] args){
        Overloading o = new Overloading();
        System.out.println(o.test());
        o.test(1);
        System.out.println(o.test(1,"test3"));
        System.out.println(o.test("test4",1));
    }
}


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   5、重写与重载之间的区别

                  区别点	重载方法	重写方法

                参数列表	必须修改	一定不能修改

                返回类型	可以修改	一定不能修改

                    异常	可以修改	可以减少或删除，一定不能抛出新的或者更广的异常

                    访问	可以修改	一定不能做更严格的限制（可以降低限制）



   6、总结

       方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   注意：

      1、重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理

         重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法


      2、重载是同样的一个方法写多次变量修饰符不一样，当调用方法时，会自动判断给入数的类型，选取其中符合的方法。


      3、补充：父类申明变量指向子类实例，该父类变量不能调用父类不存在的变量和方法，否则会抛异常

                         public class TestDog{
                            public static void main(String args[]){
                               Animal a = new Animal(); // Animal 对象
                               Animal b = new Dog(); // Dog 对象
 
                               a.move();// 执行 Animal 类的方法

                               b.move();//执行 Dog 类的方法

                               b.bark();     --------------------------> //该程序将抛出一个编译错误，因为b的引用类型Animal没有bark方法。
                            }
                         }







---------------------------------------------------------------------------------------------------------------------------------------------


  二十四、Java 多态

      多态是同一个行为具有多个不同表现形式或形态的能力。

      多态就是同一个接口，使用不同的实例而执行不同操作

      多态性是对象多种表现形式的体现。

           现实中，比如我们按下 F1 键这个动作：

                  如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；

                  如果当前在 Word 下弹出的就是 Word 帮助；

                  在 Windows 下弹出的就是 Windows 帮助和支持。

           同一个事件发生在不同的对象上会产生不同的结果。


    1、多态的优点

          1. 消除类型之间的耦合关系

          2. 可替换性

          3. 可扩充性

          4. 接口性

          5. 灵活性

          6. 简化性


   2、多态存在的三个必要条件：（重点）

               继承

               重写

               父类引用指向子类对象

        比如：

            Parent p = new Child();

     当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。

     多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。


以下是一个多态实例的演示，详细说明请看注释：
Test.java 文件代码：
public class Test {
    public static void main(String[] args) {
      show(new Cat());  // 以 Cat 对象调用 show 方法
      show(new Dog());  // 以 Dog 对象调用 show 方法
                
      Animal a = new Cat();  // 向上转型  
      a.eat();               // 调用的是 Cat 的 eat
      Cat c = (Cat)a;        // 向下转型  
      c.work();        // 调用的是 Cat 的 work
  }  
            
    public static void show(Animal a)  {
      a.eat();  
        // 类型判断
        if (a instanceof Cat)  {  // 猫做的事情 
            Cat c = (Cat)a;  
            c.work();  
        } else if (a instanceof Dog) { // 狗做的事情 
            Dog c = (Dog)a;  
            c.work();  
        }  
    }  
}
 
abstract class Animal {  
    abstract void eat();  
}  
  
class Cat extends Animal {  
    public void eat() {  
        System.out.println("吃鱼");  
    }  
    public void work() {  
        System.out.println("抓老鼠");  
    }  
}  
  
class Dog extends Animal {  
    public void eat() {  
        System.out.println("吃骨头");  
    }  
    public void work() {  
        System.out.println("看家");  
    }  
}

执行以上程序，输出结果为：

吃鱼
抓老鼠
吃骨头
看家
吃鱼
抓老鼠



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  3、虚方法

       我们将介绍在Java中，当设计类时，被重写的方法的行为怎样影响多态性。

       我们已经讨论了方法的重写，也就是子类能够重写父类的方法。
 
       当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。

       要想调用父类中被重写的方法，则必须使用关键字super。



       例子解析：

         实例中，实例化了两个 Salary 对象：一个使用 Salary 引用 s，另一个使用 Employee 引用 e。

         当调用 s.mailCheck() 时，编译器在编译时会在 Salary 类中找到 mailCheck()，执行过程 JVM 就调用 Salary 类的 mailCheck()。

         因为 e 是 Employee 的引用，所以调用 e 的 mailCheck() 方法时，编译器会去 Employee 类查找 mailCheck() 方法。

         在编译的时候，编译器使用 Employee 类中的 mailCheck() 方法验证该语句， 但是在运行的时候，Java虚拟机(JVM)调用的是 Salary 类中的 mailCheck() 方法。

         以上整个过程被称为虚拟方法调用，该方法被称为虚拟方法。

         Java中所有的方法都能以这种方式表现，因此，重写的方法能在运行时调用，不管编译的时候源代码中引用变量是什么数据类型。



   4、多态的实现方式


          方式一：重写：

              这个内容已经在上一章节详细讲过，就不再阐述，详细可访问：Java 重写(Override)与重载(Overload)。


       
          方式二：接口

              1. 生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。

              2. java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。


        
          方式三：抽象类和抽象方法


   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      对于多态，可以总结以下几点：

             一、使用父类类型的引用指向子类的对象；

             二、该引用只能调用父类中定义的方法和变量；

             三、如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）;

             四、变量不能被重写（覆盖），"重写"的概念只针对方法，如果在子类中"重写"了父类中的变量，那么在编译时会报错。


          类的属性变量是能重写（覆盖）



---------------------------------------------------------------------------------------------------------------------------------------------


   二十四、Java 抽象类


      在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。

      抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。

      由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。

      父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。

      在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。







































---------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------------------------

额外知识：

  1、 java中私有静态变量的作用：

        单例模式中就使用了私有静态变量。一个被各个类对象所共享，不提供get，set方法的变量。

         使用静态私有变量最要注意的就是不要提供可被访问的get，set方法。否则，静态私有就失去了功效了。

          private static


---------------------------------------------------------------------------------------------------------------------------------------------

  2、Java 单例模式  http://www.cnblogs.com/whgw/archive/2011/10/05/2199535.html


       java中单例模式是一种常见的设计模式，单例模式分三种：懒汉式单例、饿汉式单例、登记式单例三种。


   　　单例模式有一下特点：

　             　1、单例类只能有一个实例。

　             　2、单例类必须自己自己创建自己的唯一实例。

             　　3、单例类必须给所有其他对象提供这一实例。



      单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

            在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。

            这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。

            每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。

            总之，选择单例模式就是为了避免不一致状态，避免政出多头。



       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

             首先看一个经典的单例实现:

                     public class Singleton {

                         private static Singleton uniqueInstance = null;
 
                         private Singleton() {     //Singleton通过将构造方法限定为private避免了类在外部被实例化，

                            // Exists only to defeat instantiation.
                         }
 
                         public static Singleton getInstance() {  //在同一个虚拟机范围内，Singleton的唯一实例只能通过getInstance()方法访问。

                            if (uniqueInstance == null) {

                                uniqueInstance = new Singleton();
                            }

                            return uniqueInstance;
                         }
                         // Other methods...
                     }


        Singleton通过将构造方法限定为private避免了类在外部被实例化，在同一个虚拟机范围内，Singleton的唯一实例只能通过getInstance()方法访问。
        注意：
       
            （事实上，通过Java反射机制是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效。此问题在此处不做讨论，姑且掩耳盗铃地认为反射机制不存在。）



---------------------------------------------------------------------------------------------------------------------------------------------


 3、Class.forName

      （1）Class.forName(xxx.xx.xx) 返回的是一个类

         首先你要明白在java里面任何class都要装载在虚拟机上才能运行。这句话就是装载类用的(和new 不一样，要分清楚)。

     
      （2）至于什么时候用，你可以考虑一下这个问题，给你一个字符串变量，它代表一个类的包名和类名，你怎么实例化它？

            只有你提到的这个方法了，不过要再加一点。
 
               A a = (A)Class.forName("pacage.A").newInstance(); 

               这和你 
                        A a = new A()； 
                                      是一样的效果。 


      （3）jvm会执行静态代码段，你要记住一个概念，静态代码是和class绑定的，class装载成功就表示执行了你的静态代码了。而且以后不会再走这段静态代码了。

               Class.forName(xxx.xx.xx) 返回的是一个类 

               Class.forName(xxx.xx.xx);的作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段


      （4）动态加载和创建Class 对象，比如想根据用户输入的字符串来创建对象 

                 String str = 用户输入的字符串 

                 Class t = Class.forName(str); 

                 t.newInstance();


           问题：在初始化一个类，生成一个实例的时候，newInstance()方法和new关键字除了一个是方法，一个是关键字外，最主要有什么区别？

             答：它们的区别在于创建对象的方式不一样，前者是使用类加载机制，后者是创建一个新类。


           问题：那么为什么会有两种创建对象方式？

             答：这主要考虑到软件的可伸缩、可扩展和可重用等软件设计思想。 


      （5）Java中工厂模式经常使用newInstance()方法来创建对象，因此从为什么要使用工厂模式上可以找到具体答案。 例如： 

                  class c = Class.forName(“Example”); 

                  factory = (ExampleInterface)c.newInstance(); 


            其中ExampleInterface是Example的接口，可以写成如下形式： 

                   String className = "Example"; 

                   class c = Class.forName(className); 

                   factory = (ExampleInterface)c.newInstance(); 


            进一步可以写成如下形式：
 
                   String className = readfromXMlConfig;//从xml 配置文件中获得字符串 

                   class c = Class.forName(className);
 
                   factory = (ExampleInterface)c.newInstance(); 

           上面代码已经不存在Example的类名称，它的优点是，无论Example类怎么变化，上述代码不变，甚至可以更换Example的兄弟类Example2 , Example3 , Example4……，只要他们继承ExampleInterface就可以。



       （6）、从JVM的角度看，我们使用关键字new创建一个类的时候，这个类可以没有被加载。

              但是使用newInstance()方法的时候，就必须保证：

                                    1、这个类已经加载；

                                    2、这个类已经连接了。

              而完成上面两个步骤的正是Class的静态方法forName()所完成的，这个静态方法调用了启动类加载器，即加载 java API的那个加载器。 



       （7）现在可以看出，newInstance()实际上是把new这个方式分解为两步，即首先调用Class加载方法加载某个类，然后实例化。

              这样分步的好处是显而易见的。我们可以在调用class的静态加载方法forName时获得更好的灵活性，提供给了一种降耦的手段。 

                最后用最简单的描述来区分new关键字和newInstance()方法的区别： 

                                  newInstance: 弱类型。低效率。只能调用无参构造。 

                                  new: 强类型。相对高效。能调用任何public构造。



---------------------------------------------------------------------------------------------------------------------------------------------


  额外知识：

    4、   java 中String 是个对象，是引用类型

           基础类型与引用类型的区别是，基础类型只表示简单的字符或数字，引用类型可以是任何复杂的数据结构

           基本类型仅表示简单的数据类型，引用类型可以表示复杂的数据类型，还可以操作这种数据类型的行为

           java虚拟机处理基础类型与引用类型的方式是不一样的，对于基本类型，java虚拟机会为其分配数据类型实际占用的内存空间，而对于引用类型变量，他仅仅是一个指向堆区中某个实例的指针。



---------------------------------------------------------------------------------------------------------------------------------------------

  额外知识：

    5、 Java对象的持久化概念

          花果山猴子们的信息作为特定应用领域里的业务数据，有两种表现形式：

               1.在内存中表现为 Monkey对象。

               2.在关系数据库中表现为 MONKEYS表中的记录。


         当 Java程序在内存中创建了一个 Monkey对象后，它不可能永远存在。最后，它要么从内存中清除，要么被持久化到数据库中。

         内存无法永久地保存数据，因此必须对 Monkey 对象进行持久化。否则，如果 Monkey 对象没有被持久化，那么用户在应用程序运行时创建的猴子信息将在应用程序结束运行后随之消失。

         而一旦Monkey 对象被持久化，它就可以在应用程序再次运行时被重新加载到内存，并重新构造出 Monkey对象。



         Hibernate的英文原意是冬眠，冬眠与持久化之间有什么关系呢？

            Java对象存在于内存中，Hibernate 能够把 Java 对象永久保存到关系数据库中。

            形象地理解，可以说Hibernate能够让内存中的Java对象在关系数据库中“冬眠”。

 
        狭义的理解，“持久化”仅仅指把对象永久保存到数据库中；

        广义的理解，“持久化”包括和数据库相关的各种操作：
 
                                  保存：把对象永久保存到数据库中。

                                  更新：更新数据库中对象的状态。

                                  删除：从数据库中删除一个对象。
               
                                  加载：根据特定的 OID（Object  Identifier，对象标识符），把一个对象从数据库加载到内存中。

                                  查询：根据特定的查询条件，把符合查询条件的一个或多个对象从数据库加载到内存中。


---------------------------------------------------------------------------------------------------------------------------------------------


 额外知识

    6、java中如何将char数组转化为String？

           1.直接在构造String时建立。 char data[] = {'s', 'g', 'k'}; String str = new String(data);

           2.String有方法可以直接转换。 String.valueOf(char[] chr)就可以。

                       如： char[] cha = {'s','g','h'}; String n = String.valueOf(cha);



---------------------------------------------------------------------------------------------------------------------------------------------



















